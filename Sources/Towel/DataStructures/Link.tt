<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<# int[] dimensionsToGenerate = new int[] { 1, 2, 3, 4, 5, 6, 7 }; #>
//------------------------------------------------------------------------------
// <auto-generated>
//	  This code was generated from the "Link.tt" T4 Text Template.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using static Towel.Statics;

namespace Towel.DataStructures
{
	/// <summary>Represents a link between objects.</summary>
	public interface Link : IDataStructure<object>
	{
		#region Properties

		/// <summary>The number of objects in the tuple.</summary>
		int Size { get; }

		#endregion
	}
<# foreach (int i in dimensionsToGenerate) { #>

	/// <summary>Represents a link between objects.</summary>
<# for (int j = 1; j <= i; j++) { #>
	/// <typeparam name="T<#= j #>">The type of #<#= j #> element in the link.</typeparam>
<# } #>
	public class Link<T1
<# for (int j = 2; j <= i; j++) { #>
		, T<#= j #>
<# } #>
		> : Link
	{
<# for (int j = 1; j <= i; j++) { #>
		internal T<#= j #> __<#= j #>;
<# } #>

		#region Constructors
		
		/// <summary>
		/// Creates a link between objects.
		/// <para>Runtime: O(1)</para>
		/// </summary>
<# for (int j = 1; j <= i; j++) { #>
		/// <param name="_<#= j #>">The #<#= j #> item to be linked.</param>
<# } #>
		public Link(T1 _1
<# for (int j = 2; j <= i; j++) { #>
			, T<#= j #> _<#= j #>
<# } #>
			)
		{
<# for (int j = 1; j <= i; j++) { #>
			this.__<#= j #> = _<#= j #>;
<# } #>
		}
		
		#endregion

		#region Properties
		
		/// <summary>
		/// The number of objects in the tuple.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		public int Size => <#= i #>;
<# for (int j = 1; j <= i; j++) { #>
		/// <summary>The #<#= j #> item in the link.</summary>
		public T<#= j #> _<#= j #> { get => __<#= j #>; set => __<#= j #> = value; }
<# } #>

		#endregion

		#region Operators
<# if (i < 8) { #>

		/// <summary>Converts a System.ValueTuple to a Towel.DataStructures.Link of the same generic types.</summary>
		/// <param name="tuple">The System.ValueTuple to convert into a Towel.DataStructures.Link.</param>
		/// <returns>The resulting Towel.DataStructures.Link.</returns>
		public static explicit operator Link<T1
<# for (int j = 2; j <= i; j++) { #>
			, T<#= j #>
<# } #>
			>(System.ValueTuple<T1
<# for (int j = 2; j <= i; j++) { #>
			, T<#= j #>
<# } #>
			> tuple)
		{
			return new Link<T1
<# for (int j = 2; j <= i; j++) { #>
				, T<#= j #>
<# } #>
				>(tuple.Item1
<# for (int j = 2; j <= i; j++) { #>
				, tuple.Item<#= j #>
<# } #>
				);
		}

		/// <summary>Converts a Towel.DataStructures.Link to a System.Tuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.Link to convert into a System.ValueTuple.</param>
		/// <returns>The resulting System.ValueTuple.</returns>
		public static explicit operator System.ValueTuple<T1
<# for (int j = 2; j <= i; j++) { #>
			, T<#= j #>
<# } #>
			>(Link<T1
<# for (int j = 2; j <= i; j++) { #>
			, T<#= j #>
<# } #>
			> link)
		{
			return new System.ValueTuple<T1
<# for (int j = 2; j <= i; j++) { #>
				, T<#= j #>
<# } #>
				>((T1)link._1
<# for (int j = 2; j <= i; j++) { #>
				, (T<#= j #>)link._<#= j #>
<# } #>
				);
		}

		/// <summary>Converts a System.Tuple to a Towel.DataStructures.Link of the same generic types.</summary>
		/// <param name="tuple">The System.Tuple to convert into a Towel.DataStructures.Link.</param>
		/// <returns>The resulting Towel.DataStructures.Link.</returns>
		public static explicit operator Link<T1
<# for (int j = 2; j <= i; j++) { #>
			, T<#= j #>
<# } #>
			>(System.Tuple<T1
<# for (int j = 2; j <= i; j++) { #>
			, T<#= j #>
<# } #>
			> tuple)
		{
			return new Link<T1
<# for (int j = 2; j <= i; j++) { #>
				, T<#= j #>
<# } #>
				>(tuple.Item1
<# for (int j = 2; j <= i; j++) { #>
				, tuple.Item<#= j #>
<# } #>
				);
		}

		/// <summary>Converts a Towel.DataStructures.Link to a System.Tuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.Link to convert into a System.Tuple.</param>
		/// <returns>The resulting System.Tuple.</returns>
		public static explicit operator System.Tuple<T1
<# for (int j = 2; j <= i; j++) { #>
			, T<#= j #>
<# } #>
			>(Link<T1
<# for (int j = 2; j <= i; j++) { #>
			, T<#= j #>
<# } #>
			> link)
		{
			return new System.Tuple<T1
<# for (int j = 2; j <= i; j++) { #>
				, T<#= j #>
<# } #>
				>((T1)link._1
<# for (int j = 2; j <= i; j++) { #>
				, (T<#= j #>)link._<#= j #>
<# } #>
				);
		}
<# } #>

		#endregion

		#region Methods

		System.Collections.IEnumerator
			System.Collections.IEnumerable.GetEnumerator()
		{
<# for (int j = 1; j <= i; j++) { #>
			yield return this._<#= j #>;
<# } #>
		}
		
		System.Collections.Generic.IEnumerator<object>
			System.Collections.Generic.IEnumerable<object>.GetEnumerator()
		{
<# for (int j = 1; j <= i; j++) { #>
			yield return this._<#= j #>;
<# } #>
		}

		/// <summary>Gets an array with all the types contained in this link in respective order.</summary>
		/// <returns>An array of all the types in this link in respective order.</returns>
		public System.Type[] Types()
		{
			return new System.Type[]
			{
				typeof(T1)
<# for (int j = 2; j <= i; j++) { #>
				, typeof(T<#= j #>)
<# } #>
			};
		}

		/// <summary>Checks to see if a given object is in this data structure.</summary>
		/// <param name="item">The item to check for.</param>
		/// <param name="compare">Delegate representing comparison technique.</param>
		/// <returns>true if the item is in this structure; false if not.</returns>
		public	bool Contains(object item, Func<object, object, CompareResult> compare)
		{
<# for (int j = 1; j <= i; j++) { #>
			if (compare(this._<#= j #>, item) == CompareResult.Equal)
			{
				return true;
			}
<# } #>
			return false;
		}

		/// <inheritdoc/>
		public StepStatus StepperBreak<TStep>(TStep step = default)
			where TStep : struct, IFunc<object, StepStatus>
		{
<# for (int j = 1; j <= i; j++) { #>
			if (step.Do(_<#= j #>) is Break)
			{
				return Break;
			}
<# } #>
			return Continue;
		}

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public	IDataStructure<object> Clone()
		{
			return new Link<T1
<# for (int j = 2; j <= i; j++) { #>
				, T<#= j #>
<# } #>
				>((T1)this._1
<# for (int j = 2; j <= i; j++) { #>
				, this._<#= j #>
<# } #>
				);
		}

		/// <summary>Converts the structure into an array.</summary>
		/// <returns>An array containing all the item in the structure.</returns>
		public	object[] ToArray()
		{
			return new object[]
			{
				this._1
<# for (int j = 2; j <= i; j++) { #>
				, this._<#= j #>
<# } #>
			};
		}

		/// <summary>Default hashing function for the Towel.DataStructures.Link.</summary>
		/// <returns>The computed hash code.</returns>
		public override int GetHashCode()
		{
			return this._1.GetHashCode()
<# for (int j = 2; j <= i; j++) { #>
				^ this._<#= j #>.GetHashCode()
<# } #>
				;
		}

		/// <summary>Default equals method for Towel.DataStructures.Link.</summary>
		/// <returns>Whether this object and the provided obj are value equal.</returns>
		public override bool Equals(object obj)
		{
<# for (int j = 1; j <= i; j++) { #>
			if (!(obj as Link<T1
<# for (int k = 2; k <= i; k++) { #>
				, T<#= k #>
<# } #>
				>)._<#= j #>.Equals(this._<#= j #>))
				return false;
<# } #>
			return true;
		}

		#endregion
	}

	/// <summary>Represents a link between objects.</summary>
<# for (int j = 1; j <= i; j++) { #>
	/// <typeparam name="T<#= j #>">The type of #<#= j #> element in the link.</typeparam>
<# } #>
	public struct LinkStruct<T1
<# for (int j = 2; j <= i; j++) { #>
		, T<#= j #>
<# } #>
		> : Link
	{
<# for (int j = 1; j <= i; j++) { #>
		internal T<#= j #> __<#= j #>;
<# } #>

		#region Constructors
		
		/// <summary>
		/// Creates a link between objects.
		/// <para>Runtime: O(1)</para>
		/// </summary>
<# for (int j = 1; j <= i; j++) { #>
		/// <param name="_<#= j #>">The #<#= j #> item to be linked.</param>
<# } #>
		public LinkStruct(T1 _1
<# for (int j = 2; j <= i; j++) { #>
			, T<#= j #> _<#= j #>
<# } #>)
		{
<# for (int j = 1; j <= i; j++) { #>
			this.__<#= j #> = _<#= j #>;
<# } #>
		}
		
		#endregion

		#region Properties
		
		/// <summary>
		/// The number of objects in the tuple.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		public	int Size => <#= i #>;
<# for (int j = 1; j <= i; j++) { #>
		/// <summary>The #<#= j #> item in the link.</summary>
		public T<#= j #> _<#= j #> { get => __<#= j #>; set => __<#= j #> = value; }
<# } #>

		#endregion

		#region Operators
<# if (i < 8) { #>

		/// <summary>Converts a System.ValueTuple to a Towel.DataStructures.LinkStruct of the same generic types.</summary>
		/// <param name="tuple">The System.ValueTuple to convert into a Towel.DataStructures.LinkStruct.</param>
		/// <returns>The resulting Towel.DataStructures.LinkStruct.</returns>
		public static explicit operator LinkStruct<T1
<# for (int j = 2; j <= i; j++) { #>
			, T<#= j #>
<# } #>
			>(System.ValueTuple<T1
<# for (int j = 2; j <= i; j++) { #>, T<#= j #><# } #>> tuple)
		{
			return new LinkStruct<T1
<# for (int j = 2; j <= i; j++) { #>
				, T<#= j #>
<# } #>
				>(tuple.Item1
<# for (int j = 2; j <= i; j++) { #>
				, tuple.Item<#= j #>
<# } #>
				);
		}

		/// <summary>Converts a Towel.DataStructures.LinkStruct to a System.ValueTuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.LinkStruct to convert into a System.ValueTuple.</param>
		/// <returns>The resulting System.ValueTuple.</returns>
		public static explicit operator System.ValueTuple<T1
<# for (int j = 2; j <= i; j++) { #>
			, T<#= j #>
<# } #>
			>(LinkStruct<T1
<# for (int j = 2; j <= i; j++) { #>
				, T<#= j #>
<# } #>
				> link)
		{
			return new System.ValueTuple<T1
<# for (int j = 2; j <= i; j++) { #>
				, T<#= j #>
<# } #>
				>((T1)link._1
<# for (int j = 2; j <= i; j++) { #>
				, (T<#= j #>)link._<#= j #>
<# } #>
				);
		}

		/// <summary>Converts a System.Tuple to a Towel.DataStructures.LinkStruct of the same generic types.</summary>
		/// <param name="tuple">The System.Tuple to convert into a Towel.DataStructures.LinkStruct.</param>
		/// <returns>The resulting Towel.DataStructures.LinkStruct.</returns>
		public static explicit operator LinkStruct<T1
<# for (int j = 2; j <= i; j++) { #>
			, T<#= j #>
<# } #>
			>(System.Tuple<T1
<# for (int j = 2; j <= i; j++) { #>
			, T<#= j #>
<# } #>
			> tuple)
		{
			return new LinkStruct<T1
<# for (int j = 2; j <= i; j++) { #>
				, T<#= j #>
<# } #>
				>(tuple.Item1
<# for (int j = 2; j <= i; j++) { #>
				, tuple.Item<#= j #>
<# } #>
				);
		}

		/// <summary>Converts a Towel.DataStructures.LinkStruct to a System.Tuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.LinkStruct to convert into a System.Tuple.</param>
		/// <returns>The resulting System.Tuple.</returns>
		public static explicit operator System.Tuple<T1
<# for (int j = 2; j <= i; j++) { #>
			, T<#= j #>
<# } #>
			>(LinkStruct<T1
<# for (int j = 2; j <= i; j++) { #>
			, T<#= j #>
<# } #>
			> link)
		{
			return new System.Tuple<T1
<# for (int j = 2; j <= i; j++) { #>
				, T<#= j #>
<# } #>
				>((T1)link._1
<# for (int j = 2; j <= i; j++) { #>
				, (T<#= j #>)link._<#= j #>
<# } #>
				);
		}
<# } #>

		#endregion

		#region Methods

		/// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
		System.Collections.IEnumerator
			System.Collections.IEnumerable.GetEnumerator()
		{
<# for (int j = 1; j <= i; j++) { #>
			yield return this._<#= j #>;
<# } #>
		}

		/// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
		System.Collections.Generic.IEnumerator<object>
			System.Collections.Generic.IEnumerable<object>.GetEnumerator()
		{
<# for (int j = 1; j <= i; j++) { #>
			yield return this._<#= j #>;
<# } #>
		}

		/// <summary>Gets an array with all the types contained in this link in respective order.</summary>
		/// <returns>An array of all the types in this link in respective order.</returns>
		public System.Type[] Types()
		{
			return new System.Type[]
			{
				typeof(T1)
<# for (int j = 2; j <= i; j++) { #>
				, typeof(T<#= j #>)
<# } #>
			};
		}

		/// <summary>Checks to see if a given object is in this data structure.</summary>
		/// <param name="item">The item to check for.</param>
		/// <param name="compare">Delegate representing comparison technique.</param>
		/// <returns>true if the item is in this structure; false if not.</returns>
		public	bool Contains(object item, Func<object, object, CompareResult> compare)
		{
<# for (int j = 1; j <= i; j++) { #>
			if (compare(this._<#= j #>, item) == CompareResult.Equal)
				return true;
<# } #>
			return false;
		}

		/// <inheritdoc/>
		public StepStatus StepperBreak<TStep>(TStep step = default) where TStep : struct, IFunc<object, StepStatus>
		{
<# for (int j = 1; j <= i; j++) { #>
			if (step.Do(_<#= j #>) is Break)
			{
				return Break;
			}
<# } #>
			return Continue;
		}

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public IDataStructure<object> Clone()
		{
			return new LinkStruct<T1
<# for (int j = 2; j <= i; j++) { #>
				, T<#= j #>
<# } #>
				>((T1)this._1
<# for (int j = 2; j <= i; j++) { #>
				, this._<#= j #>
<# } #>
				);
		}

		/// <summary>Converts the structure into an array.</summary>
		/// <returns>An array containing all the item in the structure.</returns>
		public	object[] ToArray()
		{
			return new object[]
			{
				this._1
<# for (int j = 2; j <= i; j++) { #>
				, this._<#= j #>
<# } #>
			};
		}

		/// <summary>Default hashing function for the Towel.DataStructures.LinkStruct.</summary>
		/// <returns>The computed hash code.</returns>
		public override int GetHashCode()
		{
			return this._1.GetHashCode()
<# for (int j = 2; j <= i; j++) { #>
				^ this._<#= j #>.GetHashCode()
<# } #>
				;
		}

		/// <summary>Default equals method for Towel.DataStructures.LinkStruct.</summary>
		/// <returns>Whether this object and the provided obj are value equal.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is LinkStruct<T1
<# for (int k = 2; k <= i; k++) { #>
				, T<#= k #>
<# } #>
				>))
				return false;

			LinkStruct<T1
<# for (int k = 2; k <= i; k++) { #>
				, T<#= k #>
<# } #>
				> linkStruct = (LinkStruct<T1
<# for (int k = 2; k <= i; k++) { #>
				, T<#= k #>
<# } #>
				>)obj;
<# for (int j = 1; j <= i; j++) { #>
			if (!linkStruct._<#= j #>.Equals(this._<#= j #>))
				return false;
<# } #>
			return true;
		}

		#endregion
	}
<# } #>
}
