//------------------------------------------------------------------------------
// <auto-generated>
//	  This code was generated from the "Link.tt" T4 Text Template.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using static Towel.Statics;

namespace Towel.DataStructures
{
	/// <summary>Represents a link between objects.</summary>
	public interface Link : IDataStructure<object>
	{
		#region Properties

		/// <summary>The number of objects in the tuple.</summary>
		int Size { get; }

		#endregion
	}

	/// <summary>Represents a link between objects.</summary>
	/// <typeparam name="T1">The type of #1 element in the link.</typeparam>
	public class Link<T1
		> : Link
	{
		internal T1 __1;

		#region Constructors
		
		/// <summary>
		/// Creates a link between objects.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		/// <param name="_1">The #1 item to be linked.</param>
		public Link(T1 _1
			)
		{
			this.__1 = _1;
		}
		
		#endregion

		#region Properties
		
		/// <summary>
		/// The number of objects in the tuple.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		public int Size => 1;
		/// <summary>The #1 item in the link.</summary>
		public T1 _1 { get => __1; set => __1 = value; }

		#endregion

		#region Operators

		/// <summary>Converts a System.ValueTuple to a Towel.DataStructures.Link of the same generic types.</summary>
		/// <param name="tuple">The System.ValueTuple to convert into a Towel.DataStructures.Link.</param>
		/// <returns>The resulting Towel.DataStructures.Link.</returns>
		public static explicit operator Link<T1
			>(System.ValueTuple<T1
			> tuple)
		{
			return new Link<T1
				>(tuple.Item1
				);
		}

		/// <summary>Converts a Towel.DataStructures.Link to a System.Tuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.Link to convert into a System.ValueTuple.</param>
		/// <returns>The resulting System.ValueTuple.</returns>
		public static explicit operator System.ValueTuple<T1
			>(Link<T1
			> link)
		{
			return new System.ValueTuple<T1
				>((T1)link._1
				);
		}

		/// <summary>Converts a System.Tuple to a Towel.DataStructures.Link of the same generic types.</summary>
		/// <param name="tuple">The System.Tuple to convert into a Towel.DataStructures.Link.</param>
		/// <returns>The resulting Towel.DataStructures.Link.</returns>
		public static explicit operator Link<T1
			>(System.Tuple<T1
			> tuple)
		{
			return new Link<T1
				>(tuple.Item1
				);
		}

		/// <summary>Converts a Towel.DataStructures.Link to a System.Tuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.Link to convert into a System.Tuple.</param>
		/// <returns>The resulting System.Tuple.</returns>
		public static explicit operator System.Tuple<T1
			>(Link<T1
			> link)
		{
			return new System.Tuple<T1
				>((T1)link._1
				);
		}

		#endregion

		#region Methods

		System.Collections.IEnumerator
			System.Collections.IEnumerable.GetEnumerator()
		{
			yield return this._1;
		}
		
		System.Collections.Generic.IEnumerator<object>
			System.Collections.Generic.IEnumerable<object>.GetEnumerator()
		{
			yield return this._1;
		}

		/// <summary>Gets an array with all the types contained in this link in respective order.</summary>
		/// <returns>An array of all the types in this link in respective order.</returns>
		public System.Type[] Types()
		{
			return new System.Type[]
			{
				typeof(T1)
			};
		}

		/// <summary>Checks to see if a given object is in this data structure.</summary>
		/// <param name="item">The item to check for.</param>
		/// <param name="compare">Delegate representing comparison technique.</param>
		/// <returns>true if the item is in this structure; false if not.</returns>
		public	bool Contains(object item, Func<object, object, CompareResult> compare)
		{
			if (compare(this._1, item) == CompareResult.Equal)
			{
				return true;
			}
			return false;
		}

		/// <inheritdoc/>
		public StepStatus StepperBreak<TStep>(TStep step = default)
			where TStep : struct, IFunc<object, StepStatus>
		{
			if (step.Do(_1) is Break)
			{
				return Break;
			}
			return Continue;
		}

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public	IDataStructure<object> Clone()
		{
			return new Link<T1
				>((T1)this._1
				);
		}

		/// <summary>Converts the structure into an array.</summary>
		/// <returns>An array containing all the item in the structure.</returns>
		public	object[] ToArray()
		{
			return new object[]
			{
				this._1
			};
		}

		/// <summary>Default hashing function for the Towel.DataStructures.Link.</summary>
		/// <returns>The computed hash code.</returns>
		public override int GetHashCode()
		{
			return this._1.GetHashCode()
				;
		}

		/// <summary>Default equals method for Towel.DataStructures.Link.</summary>
		/// <returns>Whether this object and the provided obj are value equal.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj as Link<T1
				>)._1.Equals(this._1))
				return false;
			return true;
		}

		#endregion
	}

	/// <summary>Represents a link between objects.</summary>
	/// <typeparam name="T1">The type of #1 element in the link.</typeparam>
	public struct LinkStruct<T1
		> : Link
	{
		internal T1 __1;

		#region Constructors
		
		/// <summary>
		/// Creates a link between objects.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		/// <param name="_1">The #1 item to be linked.</param>
		public LinkStruct(T1 _1
)
		{
			this.__1 = _1;
		}
		
		#endregion

		#region Properties
		
		/// <summary>
		/// The number of objects in the tuple.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		public	int Size => 1;
		/// <summary>The #1 item in the link.</summary>
		public T1 _1 { get => __1; set => __1 = value; }

		#endregion

		#region Operators

		/// <summary>Converts a System.ValueTuple to a Towel.DataStructures.LinkStruct of the same generic types.</summary>
		/// <param name="tuple">The System.ValueTuple to convert into a Towel.DataStructures.LinkStruct.</param>
		/// <returns>The resulting Towel.DataStructures.LinkStruct.</returns>
		public static explicit operator LinkStruct<T1
			>(System.ValueTuple<T1
> tuple)
		{
			return new LinkStruct<T1
				>(tuple.Item1
				);
		}

		/// <summary>Converts a Towel.DataStructures.LinkStruct to a System.ValueTuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.LinkStruct to convert into a System.ValueTuple.</param>
		/// <returns>The resulting System.ValueTuple.</returns>
		public static explicit operator System.ValueTuple<T1
			>(LinkStruct<T1
				> link)
		{
			return new System.ValueTuple<T1
				>((T1)link._1
				);
		}

		/// <summary>Converts a System.Tuple to a Towel.DataStructures.LinkStruct of the same generic types.</summary>
		/// <param name="tuple">The System.Tuple to convert into a Towel.DataStructures.LinkStruct.</param>
		/// <returns>The resulting Towel.DataStructures.LinkStruct.</returns>
		public static explicit operator LinkStruct<T1
			>(System.Tuple<T1
			> tuple)
		{
			return new LinkStruct<T1
				>(tuple.Item1
				);
		}

		/// <summary>Converts a Towel.DataStructures.LinkStruct to a System.Tuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.LinkStruct to convert into a System.Tuple.</param>
		/// <returns>The resulting System.Tuple.</returns>
		public static explicit operator System.Tuple<T1
			>(LinkStruct<T1
			> link)
		{
			return new System.Tuple<T1
				>((T1)link._1
				);
		}

		#endregion

		#region Methods

		/// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
		System.Collections.IEnumerator
			System.Collections.IEnumerable.GetEnumerator()
		{
			yield return this._1;
		}

		/// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
		System.Collections.Generic.IEnumerator<object>
			System.Collections.Generic.IEnumerable<object>.GetEnumerator()
		{
			yield return this._1;
		}

		/// <summary>Gets an array with all the types contained in this link in respective order.</summary>
		/// <returns>An array of all the types in this link in respective order.</returns>
		public System.Type[] Types()
		{
			return new System.Type[]
			{
				typeof(T1)
			};
		}

		/// <summary>Checks to see if a given object is in this data structure.</summary>
		/// <param name="item">The item to check for.</param>
		/// <param name="compare">Delegate representing comparison technique.</param>
		/// <returns>true if the item is in this structure; false if not.</returns>
		public	bool Contains(object item, Func<object, object, CompareResult> compare)
		{
			if (compare(this._1, item) == CompareResult.Equal)
				return true;
			return false;
		}

		/// <inheritdoc/>
		public StepStatus StepperBreak<TStep>(TStep step = default) where TStep : struct, IFunc<object, StepStatus>
		{
			if (step.Do(_1) is Break)
			{
				return Break;
			}
			return Continue;
		}

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public IDataStructure<object> Clone()
		{
			return new LinkStruct<T1
				>((T1)this._1
				);
		}

		/// <summary>Converts the structure into an array.</summary>
		/// <returns>An array containing all the item in the structure.</returns>
		public	object[] ToArray()
		{
			return new object[]
			{
				this._1
			};
		}

		/// <summary>Default hashing function for the Towel.DataStructures.LinkStruct.</summary>
		/// <returns>The computed hash code.</returns>
		public override int GetHashCode()
		{
			return this._1.GetHashCode()
				;
		}

		/// <summary>Default equals method for Towel.DataStructures.LinkStruct.</summary>
		/// <returns>Whether this object and the provided obj are value equal.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is LinkStruct<T1
				>))
				return false;

			LinkStruct<T1
				> linkStruct = (LinkStruct<T1
				>)obj;
			if (!linkStruct._1.Equals(this._1))
				return false;
			return true;
		}

		#endregion
	}

	/// <summary>Represents a link between objects.</summary>
	/// <typeparam name="T1">The type of #1 element in the link.</typeparam>
	/// <typeparam name="T2">The type of #2 element in the link.</typeparam>
	public class Link<T1
		, T2
		> : Link
	{
		internal T1 __1;
		internal T2 __2;

		#region Constructors
		
		/// <summary>
		/// Creates a link between objects.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		/// <param name="_1">The #1 item to be linked.</param>
		/// <param name="_2">The #2 item to be linked.</param>
		public Link(T1 _1
			, T2 _2
			)
		{
			this.__1 = _1;
			this.__2 = _2;
		}
		
		#endregion

		#region Properties
		
		/// <summary>
		/// The number of objects in the tuple.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		public int Size => 2;
		/// <summary>The #1 item in the link.</summary>
		public T1 _1 { get => __1; set => __1 = value; }
		/// <summary>The #2 item in the link.</summary>
		public T2 _2 { get => __2; set => __2 = value; }

		#endregion

		#region Operators

		/// <summary>Converts a System.ValueTuple to a Towel.DataStructures.Link of the same generic types.</summary>
		/// <param name="tuple">The System.ValueTuple to convert into a Towel.DataStructures.Link.</param>
		/// <returns>The resulting Towel.DataStructures.Link.</returns>
		public static explicit operator Link<T1
			, T2
			>(System.ValueTuple<T1
			, T2
			> tuple)
		{
			return new Link<T1
				, T2
				>(tuple.Item1
				, tuple.Item2
				);
		}

		/// <summary>Converts a Towel.DataStructures.Link to a System.Tuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.Link to convert into a System.ValueTuple.</param>
		/// <returns>The resulting System.ValueTuple.</returns>
		public static explicit operator System.ValueTuple<T1
			, T2
			>(Link<T1
			, T2
			> link)
		{
			return new System.ValueTuple<T1
				, T2
				>((T1)link._1
				, (T2)link._2
				);
		}

		/// <summary>Converts a System.Tuple to a Towel.DataStructures.Link of the same generic types.</summary>
		/// <param name="tuple">The System.Tuple to convert into a Towel.DataStructures.Link.</param>
		/// <returns>The resulting Towel.DataStructures.Link.</returns>
		public static explicit operator Link<T1
			, T2
			>(System.Tuple<T1
			, T2
			> tuple)
		{
			return new Link<T1
				, T2
				>(tuple.Item1
				, tuple.Item2
				);
		}

		/// <summary>Converts a Towel.DataStructures.Link to a System.Tuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.Link to convert into a System.Tuple.</param>
		/// <returns>The resulting System.Tuple.</returns>
		public static explicit operator System.Tuple<T1
			, T2
			>(Link<T1
			, T2
			> link)
		{
			return new System.Tuple<T1
				, T2
				>((T1)link._1
				, (T2)link._2
				);
		}

		#endregion

		#region Methods

		System.Collections.IEnumerator
			System.Collections.IEnumerable.GetEnumerator()
		{
			yield return this._1;
			yield return this._2;
		}
		
		System.Collections.Generic.IEnumerator<object>
			System.Collections.Generic.IEnumerable<object>.GetEnumerator()
		{
			yield return this._1;
			yield return this._2;
		}

		/// <summary>Gets an array with all the types contained in this link in respective order.</summary>
		/// <returns>An array of all the types in this link in respective order.</returns>
		public System.Type[] Types()
		{
			return new System.Type[]
			{
				typeof(T1)
				, typeof(T2)
			};
		}

		/// <summary>Checks to see if a given object is in this data structure.</summary>
		/// <param name="item">The item to check for.</param>
		/// <param name="compare">Delegate representing comparison technique.</param>
		/// <returns>true if the item is in this structure; false if not.</returns>
		public	bool Contains(object item, Func<object, object, CompareResult> compare)
		{
			if (compare(this._1, item) == CompareResult.Equal)
			{
				return true;
			}
			if (compare(this._2, item) == CompareResult.Equal)
			{
				return true;
			}
			return false;
		}

		/// <inheritdoc/>
		public StepStatus StepperBreak<TStep>(TStep step = default)
			where TStep : struct, IFunc<object, StepStatus>
		{
			if (step.Do(_1) is Break)
			{
				return Break;
			}
			if (step.Do(_2) is Break)
			{
				return Break;
			}
			return Continue;
		}

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public	IDataStructure<object> Clone()
		{
			return new Link<T1
				, T2
				>((T1)this._1
				, this._2
				);
		}

		/// <summary>Converts the structure into an array.</summary>
		/// <returns>An array containing all the item in the structure.</returns>
		public	object[] ToArray()
		{
			return new object[]
			{
				this._1
				, this._2
			};
		}

		/// <summary>Default hashing function for the Towel.DataStructures.Link.</summary>
		/// <returns>The computed hash code.</returns>
		public override int GetHashCode()
		{
			return this._1.GetHashCode()
				^ this._2.GetHashCode()
				;
		}

		/// <summary>Default equals method for Towel.DataStructures.Link.</summary>
		/// <returns>Whether this object and the provided obj are value equal.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj as Link<T1
				, T2
				>)._1.Equals(this._1))
				return false;
			if (!(obj as Link<T1
				, T2
				>)._2.Equals(this._2))
				return false;
			return true;
		}

		#endregion
	}

	/// <summary>Represents a link between objects.</summary>
	/// <typeparam name="T1">The type of #1 element in the link.</typeparam>
	/// <typeparam name="T2">The type of #2 element in the link.</typeparam>
	public struct LinkStruct<T1
		, T2
		> : Link
	{
		internal T1 __1;
		internal T2 __2;

		#region Constructors
		
		/// <summary>
		/// Creates a link between objects.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		/// <param name="_1">The #1 item to be linked.</param>
		/// <param name="_2">The #2 item to be linked.</param>
		public LinkStruct(T1 _1
			, T2 _2
)
		{
			this.__1 = _1;
			this.__2 = _2;
		}
		
		#endregion

		#region Properties
		
		/// <summary>
		/// The number of objects in the tuple.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		public	int Size => 2;
		/// <summary>The #1 item in the link.</summary>
		public T1 _1 { get => __1; set => __1 = value; }
		/// <summary>The #2 item in the link.</summary>
		public T2 _2 { get => __2; set => __2 = value; }

		#endregion

		#region Operators

		/// <summary>Converts a System.ValueTuple to a Towel.DataStructures.LinkStruct of the same generic types.</summary>
		/// <param name="tuple">The System.ValueTuple to convert into a Towel.DataStructures.LinkStruct.</param>
		/// <returns>The resulting Towel.DataStructures.LinkStruct.</returns>
		public static explicit operator LinkStruct<T1
			, T2
			>(System.ValueTuple<T1
, T2> tuple)
		{
			return new LinkStruct<T1
				, T2
				>(tuple.Item1
				, tuple.Item2
				);
		}

		/// <summary>Converts a Towel.DataStructures.LinkStruct to a System.ValueTuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.LinkStruct to convert into a System.ValueTuple.</param>
		/// <returns>The resulting System.ValueTuple.</returns>
		public static explicit operator System.ValueTuple<T1
			, T2
			>(LinkStruct<T1
				, T2
				> link)
		{
			return new System.ValueTuple<T1
				, T2
				>((T1)link._1
				, (T2)link._2
				);
		}

		/// <summary>Converts a System.Tuple to a Towel.DataStructures.LinkStruct of the same generic types.</summary>
		/// <param name="tuple">The System.Tuple to convert into a Towel.DataStructures.LinkStruct.</param>
		/// <returns>The resulting Towel.DataStructures.LinkStruct.</returns>
		public static explicit operator LinkStruct<T1
			, T2
			>(System.Tuple<T1
			, T2
			> tuple)
		{
			return new LinkStruct<T1
				, T2
				>(tuple.Item1
				, tuple.Item2
				);
		}

		/// <summary>Converts a Towel.DataStructures.LinkStruct to a System.Tuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.LinkStruct to convert into a System.Tuple.</param>
		/// <returns>The resulting System.Tuple.</returns>
		public static explicit operator System.Tuple<T1
			, T2
			>(LinkStruct<T1
			, T2
			> link)
		{
			return new System.Tuple<T1
				, T2
				>((T1)link._1
				, (T2)link._2
				);
		}

		#endregion

		#region Methods

		/// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
		System.Collections.IEnumerator
			System.Collections.IEnumerable.GetEnumerator()
		{
			yield return this._1;
			yield return this._2;
		}

		/// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
		System.Collections.Generic.IEnumerator<object>
			System.Collections.Generic.IEnumerable<object>.GetEnumerator()
		{
			yield return this._1;
			yield return this._2;
		}

		/// <summary>Gets an array with all the types contained in this link in respective order.</summary>
		/// <returns>An array of all the types in this link in respective order.</returns>
		public System.Type[] Types()
		{
			return new System.Type[]
			{
				typeof(T1)
				, typeof(T2)
			};
		}

		/// <summary>Checks to see if a given object is in this data structure.</summary>
		/// <param name="item">The item to check for.</param>
		/// <param name="compare">Delegate representing comparison technique.</param>
		/// <returns>true if the item is in this structure; false if not.</returns>
		public	bool Contains(object item, Func<object, object, CompareResult> compare)
		{
			if (compare(this._1, item) == CompareResult.Equal)
				return true;
			if (compare(this._2, item) == CompareResult.Equal)
				return true;
			return false;
		}

		/// <inheritdoc/>
		public StepStatus StepperBreak<TStep>(TStep step = default) where TStep : struct, IFunc<object, StepStatus>
		{
			if (step.Do(_1) is Break)
			{
				return Break;
			}
			if (step.Do(_2) is Break)
			{
				return Break;
			}
			return Continue;
		}

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public IDataStructure<object> Clone()
		{
			return new LinkStruct<T1
				, T2
				>((T1)this._1
				, this._2
				);
		}

		/// <summary>Converts the structure into an array.</summary>
		/// <returns>An array containing all the item in the structure.</returns>
		public	object[] ToArray()
		{
			return new object[]
			{
				this._1
				, this._2
			};
		}

		/// <summary>Default hashing function for the Towel.DataStructures.LinkStruct.</summary>
		/// <returns>The computed hash code.</returns>
		public override int GetHashCode()
		{
			return this._1.GetHashCode()
				^ this._2.GetHashCode()
				;
		}

		/// <summary>Default equals method for Towel.DataStructures.LinkStruct.</summary>
		/// <returns>Whether this object and the provided obj are value equal.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is LinkStruct<T1
				, T2
				>))
				return false;

			LinkStruct<T1
				, T2
				> linkStruct = (LinkStruct<T1
				, T2
				>)obj;
			if (!linkStruct._1.Equals(this._1))
				return false;
			if (!linkStruct._2.Equals(this._2))
				return false;
			return true;
		}

		#endregion
	}

	/// <summary>Represents a link between objects.</summary>
	/// <typeparam name="T1">The type of #1 element in the link.</typeparam>
	/// <typeparam name="T2">The type of #2 element in the link.</typeparam>
	/// <typeparam name="T3">The type of #3 element in the link.</typeparam>
	public class Link<T1
		, T2
		, T3
		> : Link
	{
		internal T1 __1;
		internal T2 __2;
		internal T3 __3;

		#region Constructors
		
		/// <summary>
		/// Creates a link between objects.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		/// <param name="_1">The #1 item to be linked.</param>
		/// <param name="_2">The #2 item to be linked.</param>
		/// <param name="_3">The #3 item to be linked.</param>
		public Link(T1 _1
			, T2 _2
			, T3 _3
			)
		{
			this.__1 = _1;
			this.__2 = _2;
			this.__3 = _3;
		}
		
		#endregion

		#region Properties
		
		/// <summary>
		/// The number of objects in the tuple.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		public int Size => 3;
		/// <summary>The #1 item in the link.</summary>
		public T1 _1 { get => __1; set => __1 = value; }
		/// <summary>The #2 item in the link.</summary>
		public T2 _2 { get => __2; set => __2 = value; }
		/// <summary>The #3 item in the link.</summary>
		public T3 _3 { get => __3; set => __3 = value; }

		#endregion

		#region Operators

		/// <summary>Converts a System.ValueTuple to a Towel.DataStructures.Link of the same generic types.</summary>
		/// <param name="tuple">The System.ValueTuple to convert into a Towel.DataStructures.Link.</param>
		/// <returns>The resulting Towel.DataStructures.Link.</returns>
		public static explicit operator Link<T1
			, T2
			, T3
			>(System.ValueTuple<T1
			, T2
			, T3
			> tuple)
		{
			return new Link<T1
				, T2
				, T3
				>(tuple.Item1
				, tuple.Item2
				, tuple.Item3
				);
		}

		/// <summary>Converts a Towel.DataStructures.Link to a System.Tuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.Link to convert into a System.ValueTuple.</param>
		/// <returns>The resulting System.ValueTuple.</returns>
		public static explicit operator System.ValueTuple<T1
			, T2
			, T3
			>(Link<T1
			, T2
			, T3
			> link)
		{
			return new System.ValueTuple<T1
				, T2
				, T3
				>((T1)link._1
				, (T2)link._2
				, (T3)link._3
				);
		}

		/// <summary>Converts a System.Tuple to a Towel.DataStructures.Link of the same generic types.</summary>
		/// <param name="tuple">The System.Tuple to convert into a Towel.DataStructures.Link.</param>
		/// <returns>The resulting Towel.DataStructures.Link.</returns>
		public static explicit operator Link<T1
			, T2
			, T3
			>(System.Tuple<T1
			, T2
			, T3
			> tuple)
		{
			return new Link<T1
				, T2
				, T3
				>(tuple.Item1
				, tuple.Item2
				, tuple.Item3
				);
		}

		/// <summary>Converts a Towel.DataStructures.Link to a System.Tuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.Link to convert into a System.Tuple.</param>
		/// <returns>The resulting System.Tuple.</returns>
		public static explicit operator System.Tuple<T1
			, T2
			, T3
			>(Link<T1
			, T2
			, T3
			> link)
		{
			return new System.Tuple<T1
				, T2
				, T3
				>((T1)link._1
				, (T2)link._2
				, (T3)link._3
				);
		}

		#endregion

		#region Methods

		System.Collections.IEnumerator
			System.Collections.IEnumerable.GetEnumerator()
		{
			yield return this._1;
			yield return this._2;
			yield return this._3;
		}
		
		System.Collections.Generic.IEnumerator<object>
			System.Collections.Generic.IEnumerable<object>.GetEnumerator()
		{
			yield return this._1;
			yield return this._2;
			yield return this._3;
		}

		/// <summary>Gets an array with all the types contained in this link in respective order.</summary>
		/// <returns>An array of all the types in this link in respective order.</returns>
		public System.Type[] Types()
		{
			return new System.Type[]
			{
				typeof(T1)
				, typeof(T2)
				, typeof(T3)
			};
		}

		/// <summary>Checks to see if a given object is in this data structure.</summary>
		/// <param name="item">The item to check for.</param>
		/// <param name="compare">Delegate representing comparison technique.</param>
		/// <returns>true if the item is in this structure; false if not.</returns>
		public	bool Contains(object item, Func<object, object, CompareResult> compare)
		{
			if (compare(this._1, item) == CompareResult.Equal)
			{
				return true;
			}
			if (compare(this._2, item) == CompareResult.Equal)
			{
				return true;
			}
			if (compare(this._3, item) == CompareResult.Equal)
			{
				return true;
			}
			return false;
		}

		/// <inheritdoc/>
		public StepStatus StepperBreak<TStep>(TStep step = default)
			where TStep : struct, IFunc<object, StepStatus>
		{
			if (step.Do(_1) is Break)
			{
				return Break;
			}
			if (step.Do(_2) is Break)
			{
				return Break;
			}
			if (step.Do(_3) is Break)
			{
				return Break;
			}
			return Continue;
		}

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public	IDataStructure<object> Clone()
		{
			return new Link<T1
				, T2
				, T3
				>((T1)this._1
				, this._2
				, this._3
				);
		}

		/// <summary>Converts the structure into an array.</summary>
		/// <returns>An array containing all the item in the structure.</returns>
		public	object[] ToArray()
		{
			return new object[]
			{
				this._1
				, this._2
				, this._3
			};
		}

		/// <summary>Default hashing function for the Towel.DataStructures.Link.</summary>
		/// <returns>The computed hash code.</returns>
		public override int GetHashCode()
		{
			return this._1.GetHashCode()
				^ this._2.GetHashCode()
				^ this._3.GetHashCode()
				;
		}

		/// <summary>Default equals method for Towel.DataStructures.Link.</summary>
		/// <returns>Whether this object and the provided obj are value equal.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj as Link<T1
				, T2
				, T3
				>)._1.Equals(this._1))
				return false;
			if (!(obj as Link<T1
				, T2
				, T3
				>)._2.Equals(this._2))
				return false;
			if (!(obj as Link<T1
				, T2
				, T3
				>)._3.Equals(this._3))
				return false;
			return true;
		}

		#endregion
	}

	/// <summary>Represents a link between objects.</summary>
	/// <typeparam name="T1">The type of #1 element in the link.</typeparam>
	/// <typeparam name="T2">The type of #2 element in the link.</typeparam>
	/// <typeparam name="T3">The type of #3 element in the link.</typeparam>
	public struct LinkStruct<T1
		, T2
		, T3
		> : Link
	{
		internal T1 __1;
		internal T2 __2;
		internal T3 __3;

		#region Constructors
		
		/// <summary>
		/// Creates a link between objects.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		/// <param name="_1">The #1 item to be linked.</param>
		/// <param name="_2">The #2 item to be linked.</param>
		/// <param name="_3">The #3 item to be linked.</param>
		public LinkStruct(T1 _1
			, T2 _2
			, T3 _3
)
		{
			this.__1 = _1;
			this.__2 = _2;
			this.__3 = _3;
		}
		
		#endregion

		#region Properties
		
		/// <summary>
		/// The number of objects in the tuple.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		public	int Size => 3;
		/// <summary>The #1 item in the link.</summary>
		public T1 _1 { get => __1; set => __1 = value; }
		/// <summary>The #2 item in the link.</summary>
		public T2 _2 { get => __2; set => __2 = value; }
		/// <summary>The #3 item in the link.</summary>
		public T3 _3 { get => __3; set => __3 = value; }

		#endregion

		#region Operators

		/// <summary>Converts a System.ValueTuple to a Towel.DataStructures.LinkStruct of the same generic types.</summary>
		/// <param name="tuple">The System.ValueTuple to convert into a Towel.DataStructures.LinkStruct.</param>
		/// <returns>The resulting Towel.DataStructures.LinkStruct.</returns>
		public static explicit operator LinkStruct<T1
			, T2
			, T3
			>(System.ValueTuple<T1
, T2, T3> tuple)
		{
			return new LinkStruct<T1
				, T2
				, T3
				>(tuple.Item1
				, tuple.Item2
				, tuple.Item3
				);
		}

		/// <summary>Converts a Towel.DataStructures.LinkStruct to a System.ValueTuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.LinkStruct to convert into a System.ValueTuple.</param>
		/// <returns>The resulting System.ValueTuple.</returns>
		public static explicit operator System.ValueTuple<T1
			, T2
			, T3
			>(LinkStruct<T1
				, T2
				, T3
				> link)
		{
			return new System.ValueTuple<T1
				, T2
				, T3
				>((T1)link._1
				, (T2)link._2
				, (T3)link._3
				);
		}

		/// <summary>Converts a System.Tuple to a Towel.DataStructures.LinkStruct of the same generic types.</summary>
		/// <param name="tuple">The System.Tuple to convert into a Towel.DataStructures.LinkStruct.</param>
		/// <returns>The resulting Towel.DataStructures.LinkStruct.</returns>
		public static explicit operator LinkStruct<T1
			, T2
			, T3
			>(System.Tuple<T1
			, T2
			, T3
			> tuple)
		{
			return new LinkStruct<T1
				, T2
				, T3
				>(tuple.Item1
				, tuple.Item2
				, tuple.Item3
				);
		}

		/// <summary>Converts a Towel.DataStructures.LinkStruct to a System.Tuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.LinkStruct to convert into a System.Tuple.</param>
		/// <returns>The resulting System.Tuple.</returns>
		public static explicit operator System.Tuple<T1
			, T2
			, T3
			>(LinkStruct<T1
			, T2
			, T3
			> link)
		{
			return new System.Tuple<T1
				, T2
				, T3
				>((T1)link._1
				, (T2)link._2
				, (T3)link._3
				);
		}

		#endregion

		#region Methods

		/// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
		System.Collections.IEnumerator
			System.Collections.IEnumerable.GetEnumerator()
		{
			yield return this._1;
			yield return this._2;
			yield return this._3;
		}

		/// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
		System.Collections.Generic.IEnumerator<object>
			System.Collections.Generic.IEnumerable<object>.GetEnumerator()
		{
			yield return this._1;
			yield return this._2;
			yield return this._3;
		}

		/// <summary>Gets an array with all the types contained in this link in respective order.</summary>
		/// <returns>An array of all the types in this link in respective order.</returns>
		public System.Type[] Types()
		{
			return new System.Type[]
			{
				typeof(T1)
				, typeof(T2)
				, typeof(T3)
			};
		}

		/// <summary>Checks to see if a given object is in this data structure.</summary>
		/// <param name="item">The item to check for.</param>
		/// <param name="compare">Delegate representing comparison technique.</param>
		/// <returns>true if the item is in this structure; false if not.</returns>
		public	bool Contains(object item, Func<object, object, CompareResult> compare)
		{
			if (compare(this._1, item) == CompareResult.Equal)
				return true;
			if (compare(this._2, item) == CompareResult.Equal)
				return true;
			if (compare(this._3, item) == CompareResult.Equal)
				return true;
			return false;
		}

		/// <inheritdoc/>
		public StepStatus StepperBreak<TStep>(TStep step = default) where TStep : struct, IFunc<object, StepStatus>
		{
			if (step.Do(_1) is Break)
			{
				return Break;
			}
			if (step.Do(_2) is Break)
			{
				return Break;
			}
			if (step.Do(_3) is Break)
			{
				return Break;
			}
			return Continue;
		}

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public IDataStructure<object> Clone()
		{
			return new LinkStruct<T1
				, T2
				, T3
				>((T1)this._1
				, this._2
				, this._3
				);
		}

		/// <summary>Converts the structure into an array.</summary>
		/// <returns>An array containing all the item in the structure.</returns>
		public	object[] ToArray()
		{
			return new object[]
			{
				this._1
				, this._2
				, this._3
			};
		}

		/// <summary>Default hashing function for the Towel.DataStructures.LinkStruct.</summary>
		/// <returns>The computed hash code.</returns>
		public override int GetHashCode()
		{
			return this._1.GetHashCode()
				^ this._2.GetHashCode()
				^ this._3.GetHashCode()
				;
		}

		/// <summary>Default equals method for Towel.DataStructures.LinkStruct.</summary>
		/// <returns>Whether this object and the provided obj are value equal.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is LinkStruct<T1
				, T2
				, T3
				>))
				return false;

			LinkStruct<T1
				, T2
				, T3
				> linkStruct = (LinkStruct<T1
				, T2
				, T3
				>)obj;
			if (!linkStruct._1.Equals(this._1))
				return false;
			if (!linkStruct._2.Equals(this._2))
				return false;
			if (!linkStruct._3.Equals(this._3))
				return false;
			return true;
		}

		#endregion
	}

	/// <summary>Represents a link between objects.</summary>
	/// <typeparam name="T1">The type of #1 element in the link.</typeparam>
	/// <typeparam name="T2">The type of #2 element in the link.</typeparam>
	/// <typeparam name="T3">The type of #3 element in the link.</typeparam>
	/// <typeparam name="T4">The type of #4 element in the link.</typeparam>
	public class Link<T1
		, T2
		, T3
		, T4
		> : Link
	{
		internal T1 __1;
		internal T2 __2;
		internal T3 __3;
		internal T4 __4;

		#region Constructors
		
		/// <summary>
		/// Creates a link between objects.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		/// <param name="_1">The #1 item to be linked.</param>
		/// <param name="_2">The #2 item to be linked.</param>
		/// <param name="_3">The #3 item to be linked.</param>
		/// <param name="_4">The #4 item to be linked.</param>
		public Link(T1 _1
			, T2 _2
			, T3 _3
			, T4 _4
			)
		{
			this.__1 = _1;
			this.__2 = _2;
			this.__3 = _3;
			this.__4 = _4;
		}
		
		#endregion

		#region Properties
		
		/// <summary>
		/// The number of objects in the tuple.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		public int Size => 4;
		/// <summary>The #1 item in the link.</summary>
		public T1 _1 { get => __1; set => __1 = value; }
		/// <summary>The #2 item in the link.</summary>
		public T2 _2 { get => __2; set => __2 = value; }
		/// <summary>The #3 item in the link.</summary>
		public T3 _3 { get => __3; set => __3 = value; }
		/// <summary>The #4 item in the link.</summary>
		public T4 _4 { get => __4; set => __4 = value; }

		#endregion

		#region Operators

		/// <summary>Converts a System.ValueTuple to a Towel.DataStructures.Link of the same generic types.</summary>
		/// <param name="tuple">The System.ValueTuple to convert into a Towel.DataStructures.Link.</param>
		/// <returns>The resulting Towel.DataStructures.Link.</returns>
		public static explicit operator Link<T1
			, T2
			, T3
			, T4
			>(System.ValueTuple<T1
			, T2
			, T3
			, T4
			> tuple)
		{
			return new Link<T1
				, T2
				, T3
				, T4
				>(tuple.Item1
				, tuple.Item2
				, tuple.Item3
				, tuple.Item4
				);
		}

		/// <summary>Converts a Towel.DataStructures.Link to a System.Tuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.Link to convert into a System.ValueTuple.</param>
		/// <returns>The resulting System.ValueTuple.</returns>
		public static explicit operator System.ValueTuple<T1
			, T2
			, T3
			, T4
			>(Link<T1
			, T2
			, T3
			, T4
			> link)
		{
			return new System.ValueTuple<T1
				, T2
				, T3
				, T4
				>((T1)link._1
				, (T2)link._2
				, (T3)link._3
				, (T4)link._4
				);
		}

		/// <summary>Converts a System.Tuple to a Towel.DataStructures.Link of the same generic types.</summary>
		/// <param name="tuple">The System.Tuple to convert into a Towel.DataStructures.Link.</param>
		/// <returns>The resulting Towel.DataStructures.Link.</returns>
		public static explicit operator Link<T1
			, T2
			, T3
			, T4
			>(System.Tuple<T1
			, T2
			, T3
			, T4
			> tuple)
		{
			return new Link<T1
				, T2
				, T3
				, T4
				>(tuple.Item1
				, tuple.Item2
				, tuple.Item3
				, tuple.Item4
				);
		}

		/// <summary>Converts a Towel.DataStructures.Link to a System.Tuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.Link to convert into a System.Tuple.</param>
		/// <returns>The resulting System.Tuple.</returns>
		public static explicit operator System.Tuple<T1
			, T2
			, T3
			, T4
			>(Link<T1
			, T2
			, T3
			, T4
			> link)
		{
			return new System.Tuple<T1
				, T2
				, T3
				, T4
				>((T1)link._1
				, (T2)link._2
				, (T3)link._3
				, (T4)link._4
				);
		}

		#endregion

		#region Methods

		System.Collections.IEnumerator
			System.Collections.IEnumerable.GetEnumerator()
		{
			yield return this._1;
			yield return this._2;
			yield return this._3;
			yield return this._4;
		}
		
		System.Collections.Generic.IEnumerator<object>
			System.Collections.Generic.IEnumerable<object>.GetEnumerator()
		{
			yield return this._1;
			yield return this._2;
			yield return this._3;
			yield return this._4;
		}

		/// <summary>Gets an array with all the types contained in this link in respective order.</summary>
		/// <returns>An array of all the types in this link in respective order.</returns>
		public System.Type[] Types()
		{
			return new System.Type[]
			{
				typeof(T1)
				, typeof(T2)
				, typeof(T3)
				, typeof(T4)
			};
		}

		/// <summary>Checks to see if a given object is in this data structure.</summary>
		/// <param name="item">The item to check for.</param>
		/// <param name="compare">Delegate representing comparison technique.</param>
		/// <returns>true if the item is in this structure; false if not.</returns>
		public	bool Contains(object item, Func<object, object, CompareResult> compare)
		{
			if (compare(this._1, item) == CompareResult.Equal)
			{
				return true;
			}
			if (compare(this._2, item) == CompareResult.Equal)
			{
				return true;
			}
			if (compare(this._3, item) == CompareResult.Equal)
			{
				return true;
			}
			if (compare(this._4, item) == CompareResult.Equal)
			{
				return true;
			}
			return false;
		}

		/// <inheritdoc/>
		public StepStatus StepperBreak<TStep>(TStep step = default)
			where TStep : struct, IFunc<object, StepStatus>
		{
			if (step.Do(_1) is Break)
			{
				return Break;
			}
			if (step.Do(_2) is Break)
			{
				return Break;
			}
			if (step.Do(_3) is Break)
			{
				return Break;
			}
			if (step.Do(_4) is Break)
			{
				return Break;
			}
			return Continue;
		}

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public	IDataStructure<object> Clone()
		{
			return new Link<T1
				, T2
				, T3
				, T4
				>((T1)this._1
				, this._2
				, this._3
				, this._4
				);
		}

		/// <summary>Converts the structure into an array.</summary>
		/// <returns>An array containing all the item in the structure.</returns>
		public	object[] ToArray()
		{
			return new object[]
			{
				this._1
				, this._2
				, this._3
				, this._4
			};
		}

		/// <summary>Default hashing function for the Towel.DataStructures.Link.</summary>
		/// <returns>The computed hash code.</returns>
		public override int GetHashCode()
		{
			return this._1.GetHashCode()
				^ this._2.GetHashCode()
				^ this._3.GetHashCode()
				^ this._4.GetHashCode()
				;
		}

		/// <summary>Default equals method for Towel.DataStructures.Link.</summary>
		/// <returns>Whether this object and the provided obj are value equal.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj as Link<T1
				, T2
				, T3
				, T4
				>)._1.Equals(this._1))
				return false;
			if (!(obj as Link<T1
				, T2
				, T3
				, T4
				>)._2.Equals(this._2))
				return false;
			if (!(obj as Link<T1
				, T2
				, T3
				, T4
				>)._3.Equals(this._3))
				return false;
			if (!(obj as Link<T1
				, T2
				, T3
				, T4
				>)._4.Equals(this._4))
				return false;
			return true;
		}

		#endregion
	}

	/// <summary>Represents a link between objects.</summary>
	/// <typeparam name="T1">The type of #1 element in the link.</typeparam>
	/// <typeparam name="T2">The type of #2 element in the link.</typeparam>
	/// <typeparam name="T3">The type of #3 element in the link.</typeparam>
	/// <typeparam name="T4">The type of #4 element in the link.</typeparam>
	public struct LinkStruct<T1
		, T2
		, T3
		, T4
		> : Link
	{
		internal T1 __1;
		internal T2 __2;
		internal T3 __3;
		internal T4 __4;

		#region Constructors
		
		/// <summary>
		/// Creates a link between objects.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		/// <param name="_1">The #1 item to be linked.</param>
		/// <param name="_2">The #2 item to be linked.</param>
		/// <param name="_3">The #3 item to be linked.</param>
		/// <param name="_4">The #4 item to be linked.</param>
		public LinkStruct(T1 _1
			, T2 _2
			, T3 _3
			, T4 _4
)
		{
			this.__1 = _1;
			this.__2 = _2;
			this.__3 = _3;
			this.__4 = _4;
		}
		
		#endregion

		#region Properties
		
		/// <summary>
		/// The number of objects in the tuple.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		public	int Size => 4;
		/// <summary>The #1 item in the link.</summary>
		public T1 _1 { get => __1; set => __1 = value; }
		/// <summary>The #2 item in the link.</summary>
		public T2 _2 { get => __2; set => __2 = value; }
		/// <summary>The #3 item in the link.</summary>
		public T3 _3 { get => __3; set => __3 = value; }
		/// <summary>The #4 item in the link.</summary>
		public T4 _4 { get => __4; set => __4 = value; }

		#endregion

		#region Operators

		/// <summary>Converts a System.ValueTuple to a Towel.DataStructures.LinkStruct of the same generic types.</summary>
		/// <param name="tuple">The System.ValueTuple to convert into a Towel.DataStructures.LinkStruct.</param>
		/// <returns>The resulting Towel.DataStructures.LinkStruct.</returns>
		public static explicit operator LinkStruct<T1
			, T2
			, T3
			, T4
			>(System.ValueTuple<T1
, T2, T3, T4> tuple)
		{
			return new LinkStruct<T1
				, T2
				, T3
				, T4
				>(tuple.Item1
				, tuple.Item2
				, tuple.Item3
				, tuple.Item4
				);
		}

		/// <summary>Converts a Towel.DataStructures.LinkStruct to a System.ValueTuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.LinkStruct to convert into a System.ValueTuple.</param>
		/// <returns>The resulting System.ValueTuple.</returns>
		public static explicit operator System.ValueTuple<T1
			, T2
			, T3
			, T4
			>(LinkStruct<T1
				, T2
				, T3
				, T4
				> link)
		{
			return new System.ValueTuple<T1
				, T2
				, T3
				, T4
				>((T1)link._1
				, (T2)link._2
				, (T3)link._3
				, (T4)link._4
				);
		}

		/// <summary>Converts a System.Tuple to a Towel.DataStructures.LinkStruct of the same generic types.</summary>
		/// <param name="tuple">The System.Tuple to convert into a Towel.DataStructures.LinkStruct.</param>
		/// <returns>The resulting Towel.DataStructures.LinkStruct.</returns>
		public static explicit operator LinkStruct<T1
			, T2
			, T3
			, T4
			>(System.Tuple<T1
			, T2
			, T3
			, T4
			> tuple)
		{
			return new LinkStruct<T1
				, T2
				, T3
				, T4
				>(tuple.Item1
				, tuple.Item2
				, tuple.Item3
				, tuple.Item4
				);
		}

		/// <summary>Converts a Towel.DataStructures.LinkStruct to a System.Tuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.LinkStruct to convert into a System.Tuple.</param>
		/// <returns>The resulting System.Tuple.</returns>
		public static explicit operator System.Tuple<T1
			, T2
			, T3
			, T4
			>(LinkStruct<T1
			, T2
			, T3
			, T4
			> link)
		{
			return new System.Tuple<T1
				, T2
				, T3
				, T4
				>((T1)link._1
				, (T2)link._2
				, (T3)link._3
				, (T4)link._4
				);
		}

		#endregion

		#region Methods

		/// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
		System.Collections.IEnumerator
			System.Collections.IEnumerable.GetEnumerator()
		{
			yield return this._1;
			yield return this._2;
			yield return this._3;
			yield return this._4;
		}

		/// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
		System.Collections.Generic.IEnumerator<object>
			System.Collections.Generic.IEnumerable<object>.GetEnumerator()
		{
			yield return this._1;
			yield return this._2;
			yield return this._3;
			yield return this._4;
		}

		/// <summary>Gets an array with all the types contained in this link in respective order.</summary>
		/// <returns>An array of all the types in this link in respective order.</returns>
		public System.Type[] Types()
		{
			return new System.Type[]
			{
				typeof(T1)
				, typeof(T2)
				, typeof(T3)
				, typeof(T4)
			};
		}

		/// <summary>Checks to see if a given object is in this data structure.</summary>
		/// <param name="item">The item to check for.</param>
		/// <param name="compare">Delegate representing comparison technique.</param>
		/// <returns>true if the item is in this structure; false if not.</returns>
		public	bool Contains(object item, Func<object, object, CompareResult> compare)
		{
			if (compare(this._1, item) == CompareResult.Equal)
				return true;
			if (compare(this._2, item) == CompareResult.Equal)
				return true;
			if (compare(this._3, item) == CompareResult.Equal)
				return true;
			if (compare(this._4, item) == CompareResult.Equal)
				return true;
			return false;
		}

		/// <inheritdoc/>
		public StepStatus StepperBreak<TStep>(TStep step = default) where TStep : struct, IFunc<object, StepStatus>
		{
			if (step.Do(_1) is Break)
			{
				return Break;
			}
			if (step.Do(_2) is Break)
			{
				return Break;
			}
			if (step.Do(_3) is Break)
			{
				return Break;
			}
			if (step.Do(_4) is Break)
			{
				return Break;
			}
			return Continue;
		}

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public IDataStructure<object> Clone()
		{
			return new LinkStruct<T1
				, T2
				, T3
				, T4
				>((T1)this._1
				, this._2
				, this._3
				, this._4
				);
		}

		/// <summary>Converts the structure into an array.</summary>
		/// <returns>An array containing all the item in the structure.</returns>
		public	object[] ToArray()
		{
			return new object[]
			{
				this._1
				, this._2
				, this._3
				, this._4
			};
		}

		/// <summary>Default hashing function for the Towel.DataStructures.LinkStruct.</summary>
		/// <returns>The computed hash code.</returns>
		public override int GetHashCode()
		{
			return this._1.GetHashCode()
				^ this._2.GetHashCode()
				^ this._3.GetHashCode()
				^ this._4.GetHashCode()
				;
		}

		/// <summary>Default equals method for Towel.DataStructures.LinkStruct.</summary>
		/// <returns>Whether this object and the provided obj are value equal.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is LinkStruct<T1
				, T2
				, T3
				, T4
				>))
				return false;

			LinkStruct<T1
				, T2
				, T3
				, T4
				> linkStruct = (LinkStruct<T1
				, T2
				, T3
				, T4
				>)obj;
			if (!linkStruct._1.Equals(this._1))
				return false;
			if (!linkStruct._2.Equals(this._2))
				return false;
			if (!linkStruct._3.Equals(this._3))
				return false;
			if (!linkStruct._4.Equals(this._4))
				return false;
			return true;
		}

		#endregion
	}

	/// <summary>Represents a link between objects.</summary>
	/// <typeparam name="T1">The type of #1 element in the link.</typeparam>
	/// <typeparam name="T2">The type of #2 element in the link.</typeparam>
	/// <typeparam name="T3">The type of #3 element in the link.</typeparam>
	/// <typeparam name="T4">The type of #4 element in the link.</typeparam>
	/// <typeparam name="T5">The type of #5 element in the link.</typeparam>
	public class Link<T1
		, T2
		, T3
		, T4
		, T5
		> : Link
	{
		internal T1 __1;
		internal T2 __2;
		internal T3 __3;
		internal T4 __4;
		internal T5 __5;

		#region Constructors
		
		/// <summary>
		/// Creates a link between objects.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		/// <param name="_1">The #1 item to be linked.</param>
		/// <param name="_2">The #2 item to be linked.</param>
		/// <param name="_3">The #3 item to be linked.</param>
		/// <param name="_4">The #4 item to be linked.</param>
		/// <param name="_5">The #5 item to be linked.</param>
		public Link(T1 _1
			, T2 _2
			, T3 _3
			, T4 _4
			, T5 _5
			)
		{
			this.__1 = _1;
			this.__2 = _2;
			this.__3 = _3;
			this.__4 = _4;
			this.__5 = _5;
		}
		
		#endregion

		#region Properties
		
		/// <summary>
		/// The number of objects in the tuple.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		public int Size => 5;
		/// <summary>The #1 item in the link.</summary>
		public T1 _1 { get => __1; set => __1 = value; }
		/// <summary>The #2 item in the link.</summary>
		public T2 _2 { get => __2; set => __2 = value; }
		/// <summary>The #3 item in the link.</summary>
		public T3 _3 { get => __3; set => __3 = value; }
		/// <summary>The #4 item in the link.</summary>
		public T4 _4 { get => __4; set => __4 = value; }
		/// <summary>The #5 item in the link.</summary>
		public T5 _5 { get => __5; set => __5 = value; }

		#endregion

		#region Operators

		/// <summary>Converts a System.ValueTuple to a Towel.DataStructures.Link of the same generic types.</summary>
		/// <param name="tuple">The System.ValueTuple to convert into a Towel.DataStructures.Link.</param>
		/// <returns>The resulting Towel.DataStructures.Link.</returns>
		public static explicit operator Link<T1
			, T2
			, T3
			, T4
			, T5
			>(System.ValueTuple<T1
			, T2
			, T3
			, T4
			, T5
			> tuple)
		{
			return new Link<T1
				, T2
				, T3
				, T4
				, T5
				>(tuple.Item1
				, tuple.Item2
				, tuple.Item3
				, tuple.Item4
				, tuple.Item5
				);
		}

		/// <summary>Converts a Towel.DataStructures.Link to a System.Tuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.Link to convert into a System.ValueTuple.</param>
		/// <returns>The resulting System.ValueTuple.</returns>
		public static explicit operator System.ValueTuple<T1
			, T2
			, T3
			, T4
			, T5
			>(Link<T1
			, T2
			, T3
			, T4
			, T5
			> link)
		{
			return new System.ValueTuple<T1
				, T2
				, T3
				, T4
				, T5
				>((T1)link._1
				, (T2)link._2
				, (T3)link._3
				, (T4)link._4
				, (T5)link._5
				);
		}

		/// <summary>Converts a System.Tuple to a Towel.DataStructures.Link of the same generic types.</summary>
		/// <param name="tuple">The System.Tuple to convert into a Towel.DataStructures.Link.</param>
		/// <returns>The resulting Towel.DataStructures.Link.</returns>
		public static explicit operator Link<T1
			, T2
			, T3
			, T4
			, T5
			>(System.Tuple<T1
			, T2
			, T3
			, T4
			, T5
			> tuple)
		{
			return new Link<T1
				, T2
				, T3
				, T4
				, T5
				>(tuple.Item1
				, tuple.Item2
				, tuple.Item3
				, tuple.Item4
				, tuple.Item5
				);
		}

		/// <summary>Converts a Towel.DataStructures.Link to a System.Tuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.Link to convert into a System.Tuple.</param>
		/// <returns>The resulting System.Tuple.</returns>
		public static explicit operator System.Tuple<T1
			, T2
			, T3
			, T4
			, T5
			>(Link<T1
			, T2
			, T3
			, T4
			, T5
			> link)
		{
			return new System.Tuple<T1
				, T2
				, T3
				, T4
				, T5
				>((T1)link._1
				, (T2)link._2
				, (T3)link._3
				, (T4)link._4
				, (T5)link._5
				);
		}

		#endregion

		#region Methods

		System.Collections.IEnumerator
			System.Collections.IEnumerable.GetEnumerator()
		{
			yield return this._1;
			yield return this._2;
			yield return this._3;
			yield return this._4;
			yield return this._5;
		}
		
		System.Collections.Generic.IEnumerator<object>
			System.Collections.Generic.IEnumerable<object>.GetEnumerator()
		{
			yield return this._1;
			yield return this._2;
			yield return this._3;
			yield return this._4;
			yield return this._5;
		}

		/// <summary>Gets an array with all the types contained in this link in respective order.</summary>
		/// <returns>An array of all the types in this link in respective order.</returns>
		public System.Type[] Types()
		{
			return new System.Type[]
			{
				typeof(T1)
				, typeof(T2)
				, typeof(T3)
				, typeof(T4)
				, typeof(T5)
			};
		}

		/// <summary>Checks to see if a given object is in this data structure.</summary>
		/// <param name="item">The item to check for.</param>
		/// <param name="compare">Delegate representing comparison technique.</param>
		/// <returns>true if the item is in this structure; false if not.</returns>
		public	bool Contains(object item, Func<object, object, CompareResult> compare)
		{
			if (compare(this._1, item) == CompareResult.Equal)
			{
				return true;
			}
			if (compare(this._2, item) == CompareResult.Equal)
			{
				return true;
			}
			if (compare(this._3, item) == CompareResult.Equal)
			{
				return true;
			}
			if (compare(this._4, item) == CompareResult.Equal)
			{
				return true;
			}
			if (compare(this._5, item) == CompareResult.Equal)
			{
				return true;
			}
			return false;
		}

		/// <inheritdoc/>
		public StepStatus StepperBreak<TStep>(TStep step = default)
			where TStep : struct, IFunc<object, StepStatus>
		{
			if (step.Do(_1) is Break)
			{
				return Break;
			}
			if (step.Do(_2) is Break)
			{
				return Break;
			}
			if (step.Do(_3) is Break)
			{
				return Break;
			}
			if (step.Do(_4) is Break)
			{
				return Break;
			}
			if (step.Do(_5) is Break)
			{
				return Break;
			}
			return Continue;
		}

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public	IDataStructure<object> Clone()
		{
			return new Link<T1
				, T2
				, T3
				, T4
				, T5
				>((T1)this._1
				, this._2
				, this._3
				, this._4
				, this._5
				);
		}

		/// <summary>Converts the structure into an array.</summary>
		/// <returns>An array containing all the item in the structure.</returns>
		public	object[] ToArray()
		{
			return new object[]
			{
				this._1
				, this._2
				, this._3
				, this._4
				, this._5
			};
		}

		/// <summary>Default hashing function for the Towel.DataStructures.Link.</summary>
		/// <returns>The computed hash code.</returns>
		public override int GetHashCode()
		{
			return this._1.GetHashCode()
				^ this._2.GetHashCode()
				^ this._3.GetHashCode()
				^ this._4.GetHashCode()
				^ this._5.GetHashCode()
				;
		}

		/// <summary>Default equals method for Towel.DataStructures.Link.</summary>
		/// <returns>Whether this object and the provided obj are value equal.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj as Link<T1
				, T2
				, T3
				, T4
				, T5
				>)._1.Equals(this._1))
				return false;
			if (!(obj as Link<T1
				, T2
				, T3
				, T4
				, T5
				>)._2.Equals(this._2))
				return false;
			if (!(obj as Link<T1
				, T2
				, T3
				, T4
				, T5
				>)._3.Equals(this._3))
				return false;
			if (!(obj as Link<T1
				, T2
				, T3
				, T4
				, T5
				>)._4.Equals(this._4))
				return false;
			if (!(obj as Link<T1
				, T2
				, T3
				, T4
				, T5
				>)._5.Equals(this._5))
				return false;
			return true;
		}

		#endregion
	}

	/// <summary>Represents a link between objects.</summary>
	/// <typeparam name="T1">The type of #1 element in the link.</typeparam>
	/// <typeparam name="T2">The type of #2 element in the link.</typeparam>
	/// <typeparam name="T3">The type of #3 element in the link.</typeparam>
	/// <typeparam name="T4">The type of #4 element in the link.</typeparam>
	/// <typeparam name="T5">The type of #5 element in the link.</typeparam>
	public struct LinkStruct<T1
		, T2
		, T3
		, T4
		, T5
		> : Link
	{
		internal T1 __1;
		internal T2 __2;
		internal T3 __3;
		internal T4 __4;
		internal T5 __5;

		#region Constructors
		
		/// <summary>
		/// Creates a link between objects.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		/// <param name="_1">The #1 item to be linked.</param>
		/// <param name="_2">The #2 item to be linked.</param>
		/// <param name="_3">The #3 item to be linked.</param>
		/// <param name="_4">The #4 item to be linked.</param>
		/// <param name="_5">The #5 item to be linked.</param>
		public LinkStruct(T1 _1
			, T2 _2
			, T3 _3
			, T4 _4
			, T5 _5
)
		{
			this.__1 = _1;
			this.__2 = _2;
			this.__3 = _3;
			this.__4 = _4;
			this.__5 = _5;
		}
		
		#endregion

		#region Properties
		
		/// <summary>
		/// The number of objects in the tuple.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		public	int Size => 5;
		/// <summary>The #1 item in the link.</summary>
		public T1 _1 { get => __1; set => __1 = value; }
		/// <summary>The #2 item in the link.</summary>
		public T2 _2 { get => __2; set => __2 = value; }
		/// <summary>The #3 item in the link.</summary>
		public T3 _3 { get => __3; set => __3 = value; }
		/// <summary>The #4 item in the link.</summary>
		public T4 _4 { get => __4; set => __4 = value; }
		/// <summary>The #5 item in the link.</summary>
		public T5 _5 { get => __5; set => __5 = value; }

		#endregion

		#region Operators

		/// <summary>Converts a System.ValueTuple to a Towel.DataStructures.LinkStruct of the same generic types.</summary>
		/// <param name="tuple">The System.ValueTuple to convert into a Towel.DataStructures.LinkStruct.</param>
		/// <returns>The resulting Towel.DataStructures.LinkStruct.</returns>
		public static explicit operator LinkStruct<T1
			, T2
			, T3
			, T4
			, T5
			>(System.ValueTuple<T1
, T2, T3, T4, T5> tuple)
		{
			return new LinkStruct<T1
				, T2
				, T3
				, T4
				, T5
				>(tuple.Item1
				, tuple.Item2
				, tuple.Item3
				, tuple.Item4
				, tuple.Item5
				);
		}

		/// <summary>Converts a Towel.DataStructures.LinkStruct to a System.ValueTuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.LinkStruct to convert into a System.ValueTuple.</param>
		/// <returns>The resulting System.ValueTuple.</returns>
		public static explicit operator System.ValueTuple<T1
			, T2
			, T3
			, T4
			, T5
			>(LinkStruct<T1
				, T2
				, T3
				, T4
				, T5
				> link)
		{
			return new System.ValueTuple<T1
				, T2
				, T3
				, T4
				, T5
				>((T1)link._1
				, (T2)link._2
				, (T3)link._3
				, (T4)link._4
				, (T5)link._5
				);
		}

		/// <summary>Converts a System.Tuple to a Towel.DataStructures.LinkStruct of the same generic types.</summary>
		/// <param name="tuple">The System.Tuple to convert into a Towel.DataStructures.LinkStruct.</param>
		/// <returns>The resulting Towel.DataStructures.LinkStruct.</returns>
		public static explicit operator LinkStruct<T1
			, T2
			, T3
			, T4
			, T5
			>(System.Tuple<T1
			, T2
			, T3
			, T4
			, T5
			> tuple)
		{
			return new LinkStruct<T1
				, T2
				, T3
				, T4
				, T5
				>(tuple.Item1
				, tuple.Item2
				, tuple.Item3
				, tuple.Item4
				, tuple.Item5
				);
		}

		/// <summary>Converts a Towel.DataStructures.LinkStruct to a System.Tuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.LinkStruct to convert into a System.Tuple.</param>
		/// <returns>The resulting System.Tuple.</returns>
		public static explicit operator System.Tuple<T1
			, T2
			, T3
			, T4
			, T5
			>(LinkStruct<T1
			, T2
			, T3
			, T4
			, T5
			> link)
		{
			return new System.Tuple<T1
				, T2
				, T3
				, T4
				, T5
				>((T1)link._1
				, (T2)link._2
				, (T3)link._3
				, (T4)link._4
				, (T5)link._5
				);
		}

		#endregion

		#region Methods

		/// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
		System.Collections.IEnumerator
			System.Collections.IEnumerable.GetEnumerator()
		{
			yield return this._1;
			yield return this._2;
			yield return this._3;
			yield return this._4;
			yield return this._5;
		}

		/// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
		System.Collections.Generic.IEnumerator<object>
			System.Collections.Generic.IEnumerable<object>.GetEnumerator()
		{
			yield return this._1;
			yield return this._2;
			yield return this._3;
			yield return this._4;
			yield return this._5;
		}

		/// <summary>Gets an array with all the types contained in this link in respective order.</summary>
		/// <returns>An array of all the types in this link in respective order.</returns>
		public System.Type[] Types()
		{
			return new System.Type[]
			{
				typeof(T1)
				, typeof(T2)
				, typeof(T3)
				, typeof(T4)
				, typeof(T5)
			};
		}

		/// <summary>Checks to see if a given object is in this data structure.</summary>
		/// <param name="item">The item to check for.</param>
		/// <param name="compare">Delegate representing comparison technique.</param>
		/// <returns>true if the item is in this structure; false if not.</returns>
		public	bool Contains(object item, Func<object, object, CompareResult> compare)
		{
			if (compare(this._1, item) == CompareResult.Equal)
				return true;
			if (compare(this._2, item) == CompareResult.Equal)
				return true;
			if (compare(this._3, item) == CompareResult.Equal)
				return true;
			if (compare(this._4, item) == CompareResult.Equal)
				return true;
			if (compare(this._5, item) == CompareResult.Equal)
				return true;
			return false;
		}

		/// <inheritdoc/>
		public StepStatus StepperBreak<TStep>(TStep step = default) where TStep : struct, IFunc<object, StepStatus>
		{
			if (step.Do(_1) is Break)
			{
				return Break;
			}
			if (step.Do(_2) is Break)
			{
				return Break;
			}
			if (step.Do(_3) is Break)
			{
				return Break;
			}
			if (step.Do(_4) is Break)
			{
				return Break;
			}
			if (step.Do(_5) is Break)
			{
				return Break;
			}
			return Continue;
		}

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public IDataStructure<object> Clone()
		{
			return new LinkStruct<T1
				, T2
				, T3
				, T4
				, T5
				>((T1)this._1
				, this._2
				, this._3
				, this._4
				, this._5
				);
		}

		/// <summary>Converts the structure into an array.</summary>
		/// <returns>An array containing all the item in the structure.</returns>
		public	object[] ToArray()
		{
			return new object[]
			{
				this._1
				, this._2
				, this._3
				, this._4
				, this._5
			};
		}

		/// <summary>Default hashing function for the Towel.DataStructures.LinkStruct.</summary>
		/// <returns>The computed hash code.</returns>
		public override int GetHashCode()
		{
			return this._1.GetHashCode()
				^ this._2.GetHashCode()
				^ this._3.GetHashCode()
				^ this._4.GetHashCode()
				^ this._5.GetHashCode()
				;
		}

		/// <summary>Default equals method for Towel.DataStructures.LinkStruct.</summary>
		/// <returns>Whether this object and the provided obj are value equal.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is LinkStruct<T1
				, T2
				, T3
				, T4
				, T5
				>))
				return false;

			LinkStruct<T1
				, T2
				, T3
				, T4
				, T5
				> linkStruct = (LinkStruct<T1
				, T2
				, T3
				, T4
				, T5
				>)obj;
			if (!linkStruct._1.Equals(this._1))
				return false;
			if (!linkStruct._2.Equals(this._2))
				return false;
			if (!linkStruct._3.Equals(this._3))
				return false;
			if (!linkStruct._4.Equals(this._4))
				return false;
			if (!linkStruct._5.Equals(this._5))
				return false;
			return true;
		}

		#endregion
	}

	/// <summary>Represents a link between objects.</summary>
	/// <typeparam name="T1">The type of #1 element in the link.</typeparam>
	/// <typeparam name="T2">The type of #2 element in the link.</typeparam>
	/// <typeparam name="T3">The type of #3 element in the link.</typeparam>
	/// <typeparam name="T4">The type of #4 element in the link.</typeparam>
	/// <typeparam name="T5">The type of #5 element in the link.</typeparam>
	/// <typeparam name="T6">The type of #6 element in the link.</typeparam>
	public class Link<T1
		, T2
		, T3
		, T4
		, T5
		, T6
		> : Link
	{
		internal T1 __1;
		internal T2 __2;
		internal T3 __3;
		internal T4 __4;
		internal T5 __5;
		internal T6 __6;

		#region Constructors
		
		/// <summary>
		/// Creates a link between objects.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		/// <param name="_1">The #1 item to be linked.</param>
		/// <param name="_2">The #2 item to be linked.</param>
		/// <param name="_3">The #3 item to be linked.</param>
		/// <param name="_4">The #4 item to be linked.</param>
		/// <param name="_5">The #5 item to be linked.</param>
		/// <param name="_6">The #6 item to be linked.</param>
		public Link(T1 _1
			, T2 _2
			, T3 _3
			, T4 _4
			, T5 _5
			, T6 _6
			)
		{
			this.__1 = _1;
			this.__2 = _2;
			this.__3 = _3;
			this.__4 = _4;
			this.__5 = _5;
			this.__6 = _6;
		}
		
		#endregion

		#region Properties
		
		/// <summary>
		/// The number of objects in the tuple.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		public int Size => 6;
		/// <summary>The #1 item in the link.</summary>
		public T1 _1 { get => __1; set => __1 = value; }
		/// <summary>The #2 item in the link.</summary>
		public T2 _2 { get => __2; set => __2 = value; }
		/// <summary>The #3 item in the link.</summary>
		public T3 _3 { get => __3; set => __3 = value; }
		/// <summary>The #4 item in the link.</summary>
		public T4 _4 { get => __4; set => __4 = value; }
		/// <summary>The #5 item in the link.</summary>
		public T5 _5 { get => __5; set => __5 = value; }
		/// <summary>The #6 item in the link.</summary>
		public T6 _6 { get => __6; set => __6 = value; }

		#endregion

		#region Operators

		/// <summary>Converts a System.ValueTuple to a Towel.DataStructures.Link of the same generic types.</summary>
		/// <param name="tuple">The System.ValueTuple to convert into a Towel.DataStructures.Link.</param>
		/// <returns>The resulting Towel.DataStructures.Link.</returns>
		public static explicit operator Link<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			>(System.ValueTuple<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			> tuple)
		{
			return new Link<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				>(tuple.Item1
				, tuple.Item2
				, tuple.Item3
				, tuple.Item4
				, tuple.Item5
				, tuple.Item6
				);
		}

		/// <summary>Converts a Towel.DataStructures.Link to a System.Tuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.Link to convert into a System.ValueTuple.</param>
		/// <returns>The resulting System.ValueTuple.</returns>
		public static explicit operator System.ValueTuple<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			>(Link<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			> link)
		{
			return new System.ValueTuple<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				>((T1)link._1
				, (T2)link._2
				, (T3)link._3
				, (T4)link._4
				, (T5)link._5
				, (T6)link._6
				);
		}

		/// <summary>Converts a System.Tuple to a Towel.DataStructures.Link of the same generic types.</summary>
		/// <param name="tuple">The System.Tuple to convert into a Towel.DataStructures.Link.</param>
		/// <returns>The resulting Towel.DataStructures.Link.</returns>
		public static explicit operator Link<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			>(System.Tuple<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			> tuple)
		{
			return new Link<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				>(tuple.Item1
				, tuple.Item2
				, tuple.Item3
				, tuple.Item4
				, tuple.Item5
				, tuple.Item6
				);
		}

		/// <summary>Converts a Towel.DataStructures.Link to a System.Tuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.Link to convert into a System.Tuple.</param>
		/// <returns>The resulting System.Tuple.</returns>
		public static explicit operator System.Tuple<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			>(Link<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			> link)
		{
			return new System.Tuple<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				>((T1)link._1
				, (T2)link._2
				, (T3)link._3
				, (T4)link._4
				, (T5)link._5
				, (T6)link._6
				);
		}

		#endregion

		#region Methods

		System.Collections.IEnumerator
			System.Collections.IEnumerable.GetEnumerator()
		{
			yield return this._1;
			yield return this._2;
			yield return this._3;
			yield return this._4;
			yield return this._5;
			yield return this._6;
		}
		
		System.Collections.Generic.IEnumerator<object>
			System.Collections.Generic.IEnumerable<object>.GetEnumerator()
		{
			yield return this._1;
			yield return this._2;
			yield return this._3;
			yield return this._4;
			yield return this._5;
			yield return this._6;
		}

		/// <summary>Gets an array with all the types contained in this link in respective order.</summary>
		/// <returns>An array of all the types in this link in respective order.</returns>
		public System.Type[] Types()
		{
			return new System.Type[]
			{
				typeof(T1)
				, typeof(T2)
				, typeof(T3)
				, typeof(T4)
				, typeof(T5)
				, typeof(T6)
			};
		}

		/// <summary>Checks to see if a given object is in this data structure.</summary>
		/// <param name="item">The item to check for.</param>
		/// <param name="compare">Delegate representing comparison technique.</param>
		/// <returns>true if the item is in this structure; false if not.</returns>
		public	bool Contains(object item, Func<object, object, CompareResult> compare)
		{
			if (compare(this._1, item) == CompareResult.Equal)
			{
				return true;
			}
			if (compare(this._2, item) == CompareResult.Equal)
			{
				return true;
			}
			if (compare(this._3, item) == CompareResult.Equal)
			{
				return true;
			}
			if (compare(this._4, item) == CompareResult.Equal)
			{
				return true;
			}
			if (compare(this._5, item) == CompareResult.Equal)
			{
				return true;
			}
			if (compare(this._6, item) == CompareResult.Equal)
			{
				return true;
			}
			return false;
		}

		/// <inheritdoc/>
		public StepStatus StepperBreak<TStep>(TStep step = default)
			where TStep : struct, IFunc<object, StepStatus>
		{
			if (step.Do(_1) is Break)
			{
				return Break;
			}
			if (step.Do(_2) is Break)
			{
				return Break;
			}
			if (step.Do(_3) is Break)
			{
				return Break;
			}
			if (step.Do(_4) is Break)
			{
				return Break;
			}
			if (step.Do(_5) is Break)
			{
				return Break;
			}
			if (step.Do(_6) is Break)
			{
				return Break;
			}
			return Continue;
		}

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public	IDataStructure<object> Clone()
		{
			return new Link<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				>((T1)this._1
				, this._2
				, this._3
				, this._4
				, this._5
				, this._6
				);
		}

		/// <summary>Converts the structure into an array.</summary>
		/// <returns>An array containing all the item in the structure.</returns>
		public	object[] ToArray()
		{
			return new object[]
			{
				this._1
				, this._2
				, this._3
				, this._4
				, this._5
				, this._6
			};
		}

		/// <summary>Default hashing function for the Towel.DataStructures.Link.</summary>
		/// <returns>The computed hash code.</returns>
		public override int GetHashCode()
		{
			return this._1.GetHashCode()
				^ this._2.GetHashCode()
				^ this._3.GetHashCode()
				^ this._4.GetHashCode()
				^ this._5.GetHashCode()
				^ this._6.GetHashCode()
				;
		}

		/// <summary>Default equals method for Towel.DataStructures.Link.</summary>
		/// <returns>Whether this object and the provided obj are value equal.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj as Link<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				>)._1.Equals(this._1))
				return false;
			if (!(obj as Link<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				>)._2.Equals(this._2))
				return false;
			if (!(obj as Link<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				>)._3.Equals(this._3))
				return false;
			if (!(obj as Link<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				>)._4.Equals(this._4))
				return false;
			if (!(obj as Link<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				>)._5.Equals(this._5))
				return false;
			if (!(obj as Link<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				>)._6.Equals(this._6))
				return false;
			return true;
		}

		#endregion
	}

	/// <summary>Represents a link between objects.</summary>
	/// <typeparam name="T1">The type of #1 element in the link.</typeparam>
	/// <typeparam name="T2">The type of #2 element in the link.</typeparam>
	/// <typeparam name="T3">The type of #3 element in the link.</typeparam>
	/// <typeparam name="T4">The type of #4 element in the link.</typeparam>
	/// <typeparam name="T5">The type of #5 element in the link.</typeparam>
	/// <typeparam name="T6">The type of #6 element in the link.</typeparam>
	public struct LinkStruct<T1
		, T2
		, T3
		, T4
		, T5
		, T6
		> : Link
	{
		internal T1 __1;
		internal T2 __2;
		internal T3 __3;
		internal T4 __4;
		internal T5 __5;
		internal T6 __6;

		#region Constructors
		
		/// <summary>
		/// Creates a link between objects.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		/// <param name="_1">The #1 item to be linked.</param>
		/// <param name="_2">The #2 item to be linked.</param>
		/// <param name="_3">The #3 item to be linked.</param>
		/// <param name="_4">The #4 item to be linked.</param>
		/// <param name="_5">The #5 item to be linked.</param>
		/// <param name="_6">The #6 item to be linked.</param>
		public LinkStruct(T1 _1
			, T2 _2
			, T3 _3
			, T4 _4
			, T5 _5
			, T6 _6
)
		{
			this.__1 = _1;
			this.__2 = _2;
			this.__3 = _3;
			this.__4 = _4;
			this.__5 = _5;
			this.__6 = _6;
		}
		
		#endregion

		#region Properties
		
		/// <summary>
		/// The number of objects in the tuple.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		public	int Size => 6;
		/// <summary>The #1 item in the link.</summary>
		public T1 _1 { get => __1; set => __1 = value; }
		/// <summary>The #2 item in the link.</summary>
		public T2 _2 { get => __2; set => __2 = value; }
		/// <summary>The #3 item in the link.</summary>
		public T3 _3 { get => __3; set => __3 = value; }
		/// <summary>The #4 item in the link.</summary>
		public T4 _4 { get => __4; set => __4 = value; }
		/// <summary>The #5 item in the link.</summary>
		public T5 _5 { get => __5; set => __5 = value; }
		/// <summary>The #6 item in the link.</summary>
		public T6 _6 { get => __6; set => __6 = value; }

		#endregion

		#region Operators

		/// <summary>Converts a System.ValueTuple to a Towel.DataStructures.LinkStruct of the same generic types.</summary>
		/// <param name="tuple">The System.ValueTuple to convert into a Towel.DataStructures.LinkStruct.</param>
		/// <returns>The resulting Towel.DataStructures.LinkStruct.</returns>
		public static explicit operator LinkStruct<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			>(System.ValueTuple<T1
, T2, T3, T4, T5, T6> tuple)
		{
			return new LinkStruct<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				>(tuple.Item1
				, tuple.Item2
				, tuple.Item3
				, tuple.Item4
				, tuple.Item5
				, tuple.Item6
				);
		}

		/// <summary>Converts a Towel.DataStructures.LinkStruct to a System.ValueTuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.LinkStruct to convert into a System.ValueTuple.</param>
		/// <returns>The resulting System.ValueTuple.</returns>
		public static explicit operator System.ValueTuple<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			>(LinkStruct<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				> link)
		{
			return new System.ValueTuple<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				>((T1)link._1
				, (T2)link._2
				, (T3)link._3
				, (T4)link._4
				, (T5)link._5
				, (T6)link._6
				);
		}

		/// <summary>Converts a System.Tuple to a Towel.DataStructures.LinkStruct of the same generic types.</summary>
		/// <param name="tuple">The System.Tuple to convert into a Towel.DataStructures.LinkStruct.</param>
		/// <returns>The resulting Towel.DataStructures.LinkStruct.</returns>
		public static explicit operator LinkStruct<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			>(System.Tuple<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			> tuple)
		{
			return new LinkStruct<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				>(tuple.Item1
				, tuple.Item2
				, tuple.Item3
				, tuple.Item4
				, tuple.Item5
				, tuple.Item6
				);
		}

		/// <summary>Converts a Towel.DataStructures.LinkStruct to a System.Tuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.LinkStruct to convert into a System.Tuple.</param>
		/// <returns>The resulting System.Tuple.</returns>
		public static explicit operator System.Tuple<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			>(LinkStruct<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			> link)
		{
			return new System.Tuple<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				>((T1)link._1
				, (T2)link._2
				, (T3)link._3
				, (T4)link._4
				, (T5)link._5
				, (T6)link._6
				);
		}

		#endregion

		#region Methods

		/// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
		System.Collections.IEnumerator
			System.Collections.IEnumerable.GetEnumerator()
		{
			yield return this._1;
			yield return this._2;
			yield return this._3;
			yield return this._4;
			yield return this._5;
			yield return this._6;
		}

		/// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
		System.Collections.Generic.IEnumerator<object>
			System.Collections.Generic.IEnumerable<object>.GetEnumerator()
		{
			yield return this._1;
			yield return this._2;
			yield return this._3;
			yield return this._4;
			yield return this._5;
			yield return this._6;
		}

		/// <summary>Gets an array with all the types contained in this link in respective order.</summary>
		/// <returns>An array of all the types in this link in respective order.</returns>
		public System.Type[] Types()
		{
			return new System.Type[]
			{
				typeof(T1)
				, typeof(T2)
				, typeof(T3)
				, typeof(T4)
				, typeof(T5)
				, typeof(T6)
			};
		}

		/// <summary>Checks to see if a given object is in this data structure.</summary>
		/// <param name="item">The item to check for.</param>
		/// <param name="compare">Delegate representing comparison technique.</param>
		/// <returns>true if the item is in this structure; false if not.</returns>
		public	bool Contains(object item, Func<object, object, CompareResult> compare)
		{
			if (compare(this._1, item) == CompareResult.Equal)
				return true;
			if (compare(this._2, item) == CompareResult.Equal)
				return true;
			if (compare(this._3, item) == CompareResult.Equal)
				return true;
			if (compare(this._4, item) == CompareResult.Equal)
				return true;
			if (compare(this._5, item) == CompareResult.Equal)
				return true;
			if (compare(this._6, item) == CompareResult.Equal)
				return true;
			return false;
		}

		/// <inheritdoc/>
		public StepStatus StepperBreak<TStep>(TStep step = default) where TStep : struct, IFunc<object, StepStatus>
		{
			if (step.Do(_1) is Break)
			{
				return Break;
			}
			if (step.Do(_2) is Break)
			{
				return Break;
			}
			if (step.Do(_3) is Break)
			{
				return Break;
			}
			if (step.Do(_4) is Break)
			{
				return Break;
			}
			if (step.Do(_5) is Break)
			{
				return Break;
			}
			if (step.Do(_6) is Break)
			{
				return Break;
			}
			return Continue;
		}

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public IDataStructure<object> Clone()
		{
			return new LinkStruct<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				>((T1)this._1
				, this._2
				, this._3
				, this._4
				, this._5
				, this._6
				);
		}

		/// <summary>Converts the structure into an array.</summary>
		/// <returns>An array containing all the item in the structure.</returns>
		public	object[] ToArray()
		{
			return new object[]
			{
				this._1
				, this._2
				, this._3
				, this._4
				, this._5
				, this._6
			};
		}

		/// <summary>Default hashing function for the Towel.DataStructures.LinkStruct.</summary>
		/// <returns>The computed hash code.</returns>
		public override int GetHashCode()
		{
			return this._1.GetHashCode()
				^ this._2.GetHashCode()
				^ this._3.GetHashCode()
				^ this._4.GetHashCode()
				^ this._5.GetHashCode()
				^ this._6.GetHashCode()
				;
		}

		/// <summary>Default equals method for Towel.DataStructures.LinkStruct.</summary>
		/// <returns>Whether this object and the provided obj are value equal.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is LinkStruct<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				>))
				return false;

			LinkStruct<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				> linkStruct = (LinkStruct<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				>)obj;
			if (!linkStruct._1.Equals(this._1))
				return false;
			if (!linkStruct._2.Equals(this._2))
				return false;
			if (!linkStruct._3.Equals(this._3))
				return false;
			if (!linkStruct._4.Equals(this._4))
				return false;
			if (!linkStruct._5.Equals(this._5))
				return false;
			if (!linkStruct._6.Equals(this._6))
				return false;
			return true;
		}

		#endregion
	}

	/// <summary>Represents a link between objects.</summary>
	/// <typeparam name="T1">The type of #1 element in the link.</typeparam>
	/// <typeparam name="T2">The type of #2 element in the link.</typeparam>
	/// <typeparam name="T3">The type of #3 element in the link.</typeparam>
	/// <typeparam name="T4">The type of #4 element in the link.</typeparam>
	/// <typeparam name="T5">The type of #5 element in the link.</typeparam>
	/// <typeparam name="T6">The type of #6 element in the link.</typeparam>
	/// <typeparam name="T7">The type of #7 element in the link.</typeparam>
	public class Link<T1
		, T2
		, T3
		, T4
		, T5
		, T6
		, T7
		> : Link
	{
		internal T1 __1;
		internal T2 __2;
		internal T3 __3;
		internal T4 __4;
		internal T5 __5;
		internal T6 __6;
		internal T7 __7;

		#region Constructors
		
		/// <summary>
		/// Creates a link between objects.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		/// <param name="_1">The #1 item to be linked.</param>
		/// <param name="_2">The #2 item to be linked.</param>
		/// <param name="_3">The #3 item to be linked.</param>
		/// <param name="_4">The #4 item to be linked.</param>
		/// <param name="_5">The #5 item to be linked.</param>
		/// <param name="_6">The #6 item to be linked.</param>
		/// <param name="_7">The #7 item to be linked.</param>
		public Link(T1 _1
			, T2 _2
			, T3 _3
			, T4 _4
			, T5 _5
			, T6 _6
			, T7 _7
			)
		{
			this.__1 = _1;
			this.__2 = _2;
			this.__3 = _3;
			this.__4 = _4;
			this.__5 = _5;
			this.__6 = _6;
			this.__7 = _7;
		}
		
		#endregion

		#region Properties
		
		/// <summary>
		/// The number of objects in the tuple.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		public int Size => 7;
		/// <summary>The #1 item in the link.</summary>
		public T1 _1 { get => __1; set => __1 = value; }
		/// <summary>The #2 item in the link.</summary>
		public T2 _2 { get => __2; set => __2 = value; }
		/// <summary>The #3 item in the link.</summary>
		public T3 _3 { get => __3; set => __3 = value; }
		/// <summary>The #4 item in the link.</summary>
		public T4 _4 { get => __4; set => __4 = value; }
		/// <summary>The #5 item in the link.</summary>
		public T5 _5 { get => __5; set => __5 = value; }
		/// <summary>The #6 item in the link.</summary>
		public T6 _6 { get => __6; set => __6 = value; }
		/// <summary>The #7 item in the link.</summary>
		public T7 _7 { get => __7; set => __7 = value; }

		#endregion

		#region Operators

		/// <summary>Converts a System.ValueTuple to a Towel.DataStructures.Link of the same generic types.</summary>
		/// <param name="tuple">The System.ValueTuple to convert into a Towel.DataStructures.Link.</param>
		/// <returns>The resulting Towel.DataStructures.Link.</returns>
		public static explicit operator Link<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			, T7
			>(System.ValueTuple<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			, T7
			> tuple)
		{
			return new Link<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				, T7
				>(tuple.Item1
				, tuple.Item2
				, tuple.Item3
				, tuple.Item4
				, tuple.Item5
				, tuple.Item6
				, tuple.Item7
				);
		}

		/// <summary>Converts a Towel.DataStructures.Link to a System.Tuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.Link to convert into a System.ValueTuple.</param>
		/// <returns>The resulting System.ValueTuple.</returns>
		public static explicit operator System.ValueTuple<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			, T7
			>(Link<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			, T7
			> link)
		{
			return new System.ValueTuple<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				, T7
				>((T1)link._1
				, (T2)link._2
				, (T3)link._3
				, (T4)link._4
				, (T5)link._5
				, (T6)link._6
				, (T7)link._7
				);
		}

		/// <summary>Converts a System.Tuple to a Towel.DataStructures.Link of the same generic types.</summary>
		/// <param name="tuple">The System.Tuple to convert into a Towel.DataStructures.Link.</param>
		/// <returns>The resulting Towel.DataStructures.Link.</returns>
		public static explicit operator Link<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			, T7
			>(System.Tuple<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			, T7
			> tuple)
		{
			return new Link<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				, T7
				>(tuple.Item1
				, tuple.Item2
				, tuple.Item3
				, tuple.Item4
				, tuple.Item5
				, tuple.Item6
				, tuple.Item7
				);
		}

		/// <summary>Converts a Towel.DataStructures.Link to a System.Tuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.Link to convert into a System.Tuple.</param>
		/// <returns>The resulting System.Tuple.</returns>
		public static explicit operator System.Tuple<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			, T7
			>(Link<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			, T7
			> link)
		{
			return new System.Tuple<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				, T7
				>((T1)link._1
				, (T2)link._2
				, (T3)link._3
				, (T4)link._4
				, (T5)link._5
				, (T6)link._6
				, (T7)link._7
				);
		}

		#endregion

		#region Methods

		System.Collections.IEnumerator
			System.Collections.IEnumerable.GetEnumerator()
		{
			yield return this._1;
			yield return this._2;
			yield return this._3;
			yield return this._4;
			yield return this._5;
			yield return this._6;
			yield return this._7;
		}
		
		System.Collections.Generic.IEnumerator<object>
			System.Collections.Generic.IEnumerable<object>.GetEnumerator()
		{
			yield return this._1;
			yield return this._2;
			yield return this._3;
			yield return this._4;
			yield return this._5;
			yield return this._6;
			yield return this._7;
		}

		/// <summary>Gets an array with all the types contained in this link in respective order.</summary>
		/// <returns>An array of all the types in this link in respective order.</returns>
		public System.Type[] Types()
		{
			return new System.Type[]
			{
				typeof(T1)
				, typeof(T2)
				, typeof(T3)
				, typeof(T4)
				, typeof(T5)
				, typeof(T6)
				, typeof(T7)
			};
		}

		/// <summary>Checks to see if a given object is in this data structure.</summary>
		/// <param name="item">The item to check for.</param>
		/// <param name="compare">Delegate representing comparison technique.</param>
		/// <returns>true if the item is in this structure; false if not.</returns>
		public	bool Contains(object item, Func<object, object, CompareResult> compare)
		{
			if (compare(this._1, item) == CompareResult.Equal)
			{
				return true;
			}
			if (compare(this._2, item) == CompareResult.Equal)
			{
				return true;
			}
			if (compare(this._3, item) == CompareResult.Equal)
			{
				return true;
			}
			if (compare(this._4, item) == CompareResult.Equal)
			{
				return true;
			}
			if (compare(this._5, item) == CompareResult.Equal)
			{
				return true;
			}
			if (compare(this._6, item) == CompareResult.Equal)
			{
				return true;
			}
			if (compare(this._7, item) == CompareResult.Equal)
			{
				return true;
			}
			return false;
		}

		/// <inheritdoc/>
		public StepStatus StepperBreak<TStep>(TStep step = default)
			where TStep : struct, IFunc<object, StepStatus>
		{
			if (step.Do(_1) is Break)
			{
				return Break;
			}
			if (step.Do(_2) is Break)
			{
				return Break;
			}
			if (step.Do(_3) is Break)
			{
				return Break;
			}
			if (step.Do(_4) is Break)
			{
				return Break;
			}
			if (step.Do(_5) is Break)
			{
				return Break;
			}
			if (step.Do(_6) is Break)
			{
				return Break;
			}
			if (step.Do(_7) is Break)
			{
				return Break;
			}
			return Continue;
		}

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public	IDataStructure<object> Clone()
		{
			return new Link<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				, T7
				>((T1)this._1
				, this._2
				, this._3
				, this._4
				, this._5
				, this._6
				, this._7
				);
		}

		/// <summary>Converts the structure into an array.</summary>
		/// <returns>An array containing all the item in the structure.</returns>
		public	object[] ToArray()
		{
			return new object[]
			{
				this._1
				, this._2
				, this._3
				, this._4
				, this._5
				, this._6
				, this._7
			};
		}

		/// <summary>Default hashing function for the Towel.DataStructures.Link.</summary>
		/// <returns>The computed hash code.</returns>
		public override int GetHashCode()
		{
			return this._1.GetHashCode()
				^ this._2.GetHashCode()
				^ this._3.GetHashCode()
				^ this._4.GetHashCode()
				^ this._5.GetHashCode()
				^ this._6.GetHashCode()
				^ this._7.GetHashCode()
				;
		}

		/// <summary>Default equals method for Towel.DataStructures.Link.</summary>
		/// <returns>Whether this object and the provided obj are value equal.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj as Link<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				, T7
				>)._1.Equals(this._1))
				return false;
			if (!(obj as Link<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				, T7
				>)._2.Equals(this._2))
				return false;
			if (!(obj as Link<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				, T7
				>)._3.Equals(this._3))
				return false;
			if (!(obj as Link<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				, T7
				>)._4.Equals(this._4))
				return false;
			if (!(obj as Link<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				, T7
				>)._5.Equals(this._5))
				return false;
			if (!(obj as Link<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				, T7
				>)._6.Equals(this._6))
				return false;
			if (!(obj as Link<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				, T7
				>)._7.Equals(this._7))
				return false;
			return true;
		}

		#endregion
	}

	/// <summary>Represents a link between objects.</summary>
	/// <typeparam name="T1">The type of #1 element in the link.</typeparam>
	/// <typeparam name="T2">The type of #2 element in the link.</typeparam>
	/// <typeparam name="T3">The type of #3 element in the link.</typeparam>
	/// <typeparam name="T4">The type of #4 element in the link.</typeparam>
	/// <typeparam name="T5">The type of #5 element in the link.</typeparam>
	/// <typeparam name="T6">The type of #6 element in the link.</typeparam>
	/// <typeparam name="T7">The type of #7 element in the link.</typeparam>
	public struct LinkStruct<T1
		, T2
		, T3
		, T4
		, T5
		, T6
		, T7
		> : Link
	{
		internal T1 __1;
		internal T2 __2;
		internal T3 __3;
		internal T4 __4;
		internal T5 __5;
		internal T6 __6;
		internal T7 __7;

		#region Constructors
		
		/// <summary>
		/// Creates a link between objects.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		/// <param name="_1">The #1 item to be linked.</param>
		/// <param name="_2">The #2 item to be linked.</param>
		/// <param name="_3">The #3 item to be linked.</param>
		/// <param name="_4">The #4 item to be linked.</param>
		/// <param name="_5">The #5 item to be linked.</param>
		/// <param name="_6">The #6 item to be linked.</param>
		/// <param name="_7">The #7 item to be linked.</param>
		public LinkStruct(T1 _1
			, T2 _2
			, T3 _3
			, T4 _4
			, T5 _5
			, T6 _6
			, T7 _7
)
		{
			this.__1 = _1;
			this.__2 = _2;
			this.__3 = _3;
			this.__4 = _4;
			this.__5 = _5;
			this.__6 = _6;
			this.__7 = _7;
		}
		
		#endregion

		#region Properties
		
		/// <summary>
		/// The number of objects in the tuple.
		/// <para>Runtime: O(1)</para>
		/// </summary>
		public	int Size => 7;
		/// <summary>The #1 item in the link.</summary>
		public T1 _1 { get => __1; set => __1 = value; }
		/// <summary>The #2 item in the link.</summary>
		public T2 _2 { get => __2; set => __2 = value; }
		/// <summary>The #3 item in the link.</summary>
		public T3 _3 { get => __3; set => __3 = value; }
		/// <summary>The #4 item in the link.</summary>
		public T4 _4 { get => __4; set => __4 = value; }
		/// <summary>The #5 item in the link.</summary>
		public T5 _5 { get => __5; set => __5 = value; }
		/// <summary>The #6 item in the link.</summary>
		public T6 _6 { get => __6; set => __6 = value; }
		/// <summary>The #7 item in the link.</summary>
		public T7 _7 { get => __7; set => __7 = value; }

		#endregion

		#region Operators

		/// <summary>Converts a System.ValueTuple to a Towel.DataStructures.LinkStruct of the same generic types.</summary>
		/// <param name="tuple">The System.ValueTuple to convert into a Towel.DataStructures.LinkStruct.</param>
		/// <returns>The resulting Towel.DataStructures.LinkStruct.</returns>
		public static explicit operator LinkStruct<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			, T7
			>(System.ValueTuple<T1
, T2, T3, T4, T5, T6, T7> tuple)
		{
			return new LinkStruct<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				, T7
				>(tuple.Item1
				, tuple.Item2
				, tuple.Item3
				, tuple.Item4
				, tuple.Item5
				, tuple.Item6
				, tuple.Item7
				);
		}

		/// <summary>Converts a Towel.DataStructures.LinkStruct to a System.ValueTuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.LinkStruct to convert into a System.ValueTuple.</param>
		/// <returns>The resulting System.ValueTuple.</returns>
		public static explicit operator System.ValueTuple<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			, T7
			>(LinkStruct<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				, T7
				> link)
		{
			return new System.ValueTuple<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				, T7
				>((T1)link._1
				, (T2)link._2
				, (T3)link._3
				, (T4)link._4
				, (T5)link._5
				, (T6)link._6
				, (T7)link._7
				);
		}

		/// <summary>Converts a System.Tuple to a Towel.DataStructures.LinkStruct of the same generic types.</summary>
		/// <param name="tuple">The System.Tuple to convert into a Towel.DataStructures.LinkStruct.</param>
		/// <returns>The resulting Towel.DataStructures.LinkStruct.</returns>
		public static explicit operator LinkStruct<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			, T7
			>(System.Tuple<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			, T7
			> tuple)
		{
			return new LinkStruct<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				, T7
				>(tuple.Item1
				, tuple.Item2
				, tuple.Item3
				, tuple.Item4
				, tuple.Item5
				, tuple.Item6
				, tuple.Item7
				);
		}

		/// <summary>Converts a Towel.DataStructures.LinkStruct to a System.Tuple of the same generic types.</summary>
		/// <param name="link">The Towel.DataStructures.LinkStruct to convert into a System.Tuple.</param>
		/// <returns>The resulting System.Tuple.</returns>
		public static explicit operator System.Tuple<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			, T7
			>(LinkStruct<T1
			, T2
			, T3
			, T4
			, T5
			, T6
			, T7
			> link)
		{
			return new System.Tuple<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				, T7
				>((T1)link._1
				, (T2)link._2
				, (T3)link._3
				, (T4)link._4
				, (T5)link._5
				, (T6)link._6
				, (T7)link._7
				);
		}

		#endregion

		#region Methods

		/// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
		System.Collections.IEnumerator
			System.Collections.IEnumerable.GetEnumerator()
		{
			yield return this._1;
			yield return this._2;
			yield return this._3;
			yield return this._4;
			yield return this._5;
			yield return this._6;
			yield return this._7;
		}

		/// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
		System.Collections.Generic.IEnumerator<object>
			System.Collections.Generic.IEnumerable<object>.GetEnumerator()
		{
			yield return this._1;
			yield return this._2;
			yield return this._3;
			yield return this._4;
			yield return this._5;
			yield return this._6;
			yield return this._7;
		}

		/// <summary>Gets an array with all the types contained in this link in respective order.</summary>
		/// <returns>An array of all the types in this link in respective order.</returns>
		public System.Type[] Types()
		{
			return new System.Type[]
			{
				typeof(T1)
				, typeof(T2)
				, typeof(T3)
				, typeof(T4)
				, typeof(T5)
				, typeof(T6)
				, typeof(T7)
			};
		}

		/// <summary>Checks to see if a given object is in this data structure.</summary>
		/// <param name="item">The item to check for.</param>
		/// <param name="compare">Delegate representing comparison technique.</param>
		/// <returns>true if the item is in this structure; false if not.</returns>
		public	bool Contains(object item, Func<object, object, CompareResult> compare)
		{
			if (compare(this._1, item) == CompareResult.Equal)
				return true;
			if (compare(this._2, item) == CompareResult.Equal)
				return true;
			if (compare(this._3, item) == CompareResult.Equal)
				return true;
			if (compare(this._4, item) == CompareResult.Equal)
				return true;
			if (compare(this._5, item) == CompareResult.Equal)
				return true;
			if (compare(this._6, item) == CompareResult.Equal)
				return true;
			if (compare(this._7, item) == CompareResult.Equal)
				return true;
			return false;
		}

		/// <inheritdoc/>
		public StepStatus StepperBreak<TStep>(TStep step = default) where TStep : struct, IFunc<object, StepStatus>
		{
			if (step.Do(_1) is Break)
			{
				return Break;
			}
			if (step.Do(_2) is Break)
			{
				return Break;
			}
			if (step.Do(_3) is Break)
			{
				return Break;
			}
			if (step.Do(_4) is Break)
			{
				return Break;
			}
			if (step.Do(_5) is Break)
			{
				return Break;
			}
			if (step.Do(_6) is Break)
			{
				return Break;
			}
			if (step.Do(_7) is Break)
			{
				return Break;
			}
			return Continue;
		}

		/// <summary>Creates a shallow clone of this data structure.</summary>
		/// <returns>A shallow clone of this data structure.</returns>
		public IDataStructure<object> Clone()
		{
			return new LinkStruct<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				, T7
				>((T1)this._1
				, this._2
				, this._3
				, this._4
				, this._5
				, this._6
				, this._7
				);
		}

		/// <summary>Converts the structure into an array.</summary>
		/// <returns>An array containing all the item in the structure.</returns>
		public	object[] ToArray()
		{
			return new object[]
			{
				this._1
				, this._2
				, this._3
				, this._4
				, this._5
				, this._6
				, this._7
			};
		}

		/// <summary>Default hashing function for the Towel.DataStructures.LinkStruct.</summary>
		/// <returns>The computed hash code.</returns>
		public override int GetHashCode()
		{
			return this._1.GetHashCode()
				^ this._2.GetHashCode()
				^ this._3.GetHashCode()
				^ this._4.GetHashCode()
				^ this._5.GetHashCode()
				^ this._6.GetHashCode()
				^ this._7.GetHashCode()
				;
		}

		/// <summary>Default equals method for Towel.DataStructures.LinkStruct.</summary>
		/// <returns>Whether this object and the provided obj are value equal.</returns>
		public override bool Equals(object obj)
		{
			if (!(obj is LinkStruct<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				, T7
				>))
				return false;

			LinkStruct<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				, T7
				> linkStruct = (LinkStruct<T1
				, T2
				, T3
				, T4
				, T5
				, T6
				, T7
				>)obj;
			if (!linkStruct._1.Equals(this._1))
				return false;
			if (!linkStruct._2.Equals(this._2))
				return false;
			if (!linkStruct._3.Equals(this._3))
				return false;
			if (!linkStruct._4.Equals(this._4))
				return false;
			if (!linkStruct._5.Equals(this._5))
				return false;
			if (!linkStruct._6.Equals(this._6))
				return false;
			if (!linkStruct._7.Equals(this._7))
				return false;
			return true;
		}

		#endregion
	}
}
